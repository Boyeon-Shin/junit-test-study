# 6. 비동기 코드 단위 테스트

---

동기 코드

: 작업이 순차적으로 실행 → 예측 가능

비동기 코드

: 작업이 완료되기까지 기다리지 않고 다음 코드가 실행됨 → 순차적이지 않을 수 있음. 예측 불가능

→ 작업 완료 시점을 제어해야 하므로 테스트시 대기,타임아웃 처리가 필요함

## 6.1 비동기 데이터 가져오기

---

<aside>

예제 시나리오

---

[**example.com](http://example.com)** 이라는 웹 사이트가 정상적으로 작동하는지 확인하는 모듈이 있다고 가정

- 2XX 아니면 실패
- body에 “예시가 되는(illustrative)” 포함 시 성공
- 포함 안 되면 “text missing” 실패
</aside>

I/O 작업은 CPU 보다 느림

→  네트워크 응답을 기다리는 동안 스레드를 점유하지 않고 다른 작업 수행을 위해 **비동기**를 사용할 것임.

- **비동기를 다루는 두 가지 방법 (콜백 메커니즘, async/await)**
    
    ![image.png](6%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%EC%BD%94%EB%93%9C%20%EB%8B%A8%EC%9C%84%20%ED%85%8C%EC%8A%A4%ED%8A%B8%2025a747dafe1780c4baa0c8be21a71213/image.png)
    
    - 콜백 방식 → “작업 끝나면 이 함수를 실행해줘” 하고 함수 자체를 전달
    - async/await 방식 → “작업의 결과를 미래에 돌려줄게(Promise/Future)” 하고, 호출자는 await으로 마치 동기처럼 값을 받음

예제 6-1 isWebsiteAlive() 콜백 버전과 async/await 유사 버전

- `HealthResult`
    
    ```java
    package ch06;
    
    public record HealthResult(boolean success, String status) {}
    ```
    
- `WebsiteHealthHttpClient`  - 웹사이트가 정상 동작 하는지 검사하는 HTTP 클라이언트 클래스
    
    ```java
    package ch06.v1.httpClient;
    
    import ch06.v1.HealthResult;
    import java.net.URI;
    import java.net.http.HttpClient;
    import java.net.http.HttpRequest;
    import java.net.http.HttpResponse;
    import java.util.concurrent.CompletableFuture;
    import java.util.function.Consumer;
    
    public class WebsiteHealthHttpClient {
    
        private static final String url = "http://example.com";
        private final HttpClient client = HttpClient.newHttpClient();
    
        // 콜백 버전
        public void isWebsiteAliveWithCallback(Consumer<HealthResult> callback) {
    			  // GET 요청 생성
            HttpRequest req = HttpRequest.newBuilder(URI.create(url)).GET().build();
    				
    				// 비동기 요청 시작
            client.sendAsync(req, HttpResponse.BodyHandlers.ofString())
    				        //응답이 도착하면 실행
                    .thenApply(resp -> {
                        if (resp.statusCode() / 100 != 2) {
                            throw new RuntimeException("HTTP " + resp.statusCode());
                        }
                        return resp.body();
                    })
                    .thenApply(body -> {
                        if (body.contains("illustrative")) {
                            return new HealthResult(true, "ok");
                        } else {
                            return new HealthResult(false, "text missing");
                        }
                    })
                    .exceptionally(ex -> {
                        return new HealthResult(false, ex.getMessage());
                    })
                    .thenAccept(callback); //처리된 최종 HealthResult 객체를 매개변수로 받은 callback 함수에 전달하여 실행
        }
    
        // async/await 유사 (CompletableFuture<HealthResult> 객체 자체를 반환, 호출한 쪽에서 future을 능동적으로 가져올 수 있음))
        public CompletableFuture<HealthResult> isWebsiteAliveWithAsyncAwait() {
            HttpRequest req = HttpRequest.newBuilder(URI.create(url)).GET().build();
    
            return client.sendAsync(req, HttpResponse.BodyHandlers.ofString())
                    .thenApply(resp -> {
                        if (resp.statusCode() / 100 != 2) {
                            throw new RuntimeException("HTTP " + resp.statusCode());
                        }
                        return resp.body();
                    })
                    .thenApply(body -> {
                        if (body.contains("illustrative")) {
                            return new HealthResult(true, "ok");
                        }
                        throw new RuntimeException("text missing");
                    })
                    .exceptionally(ex -> {
                        return new HealthResult(false, ex.getMessage());
                    });
                    //.thenAccept(callback)이 없음
        }
    }
    ```
    
    [동작]
    
    1. sendAsync(..)
        - 요청 전송을 백그라운드 스레드에게 맡기고, 즉시CompletableFutuere<HttpResponse<String>> 반환
        - 메인 메인 스레드는 멈추지 않음
    2. thenApply()
        - 응답이 정상적으로 도착하면 실행
        - 결과 값을 변환 (동기)
    3. thenAccept()
        - 앞 단계가 정상 완료되면, 그 결과값을 Consumer<T> (즉, callback)의 accept(value)에 전달해 실행함
        - 결과값을 사용(소비)만 하고, 새로운 값은 반환하지 않음
        - `thenAccept(callback) = thenAccept(result -> callback.accept(result))`
        
    - 추가 코드 설명
        
        ```java
        public <T> CompletableFuture<HttpResponse<T>> 
            sendAsync(HttpRequest request, HttpResponse.BodyHandler<T> responseBodyHandler)
        ```
        
        - HttpRequest: 보낼 HTTP 요청.
        - HttpResponse.BodyHandler<T>: 응답 body를 어떤 타입으로 변환할지 지정.
        - 반환값: CompletableFuture<HttpResponse<T>>
        
        ```java
        HttpResponse.BodyHandlers.ofString()
        ```
        
        - 응답 body를 문자열(String) 로 변환해주는 BodyHandler
            
            → 그래서 최종적으로 HttpResponse<String> 이 생성
            
        
    - 코드로 보는 콜백 버전과 CompletableFuture 반환 버전 차이
        
        ```java
        public void isWebsiteAliveWithCallback(Consumer<HealthResult> callback) { ... }
        ```
        
        - 리턴값 x (void)
        - 최종 결과는 반드시 callback.accept(result)를 통해 밖으로 전달
        - 호출자 입장: 메서드만 부르고, 결과는 나중에 콜백으로 돌아옴
        - 테스트에서는 보통 CountDownLatch 같은 걸로 콜백을 기다림
        
        ```java
        public CompletableFuture<HealthResult> isWebsiteAliveWithAsyncAwait() { ... }
        ```
        
        - 리턴값 CompletableFuture
        - 호출자 입장
            - future.thenAccept(…)을 붙여 콜백으로 쓸 수도 있고
            - future.join() 해서 동기처럼 결과를 받을 수 있음
            
            → 호출자가 선택할 수 있으므로 더 유연함
            
        
    

[여러 HTTP 클라이언트(RestTemplate, HttpClient, WebClient)](https://www.notion.so/HTTP-RestTemplate-HttpClient-WebClient-271747dafe1780db842ccbdcc66e7c78?pvs=21)

[비동기 반환 유형(Async Return Type)](https://www.notion.so/Async-Return-Type-261747dafe17806eb688d221f67ecf16?pvs=21)

### 6.1.1 통합테스트를 이용한 첫 시도

---

통합테스트 작성해보기

예제 6-2 초기 통합 테스트

```java
package ch06.v1.httpClient;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

class WebsiteHealthHttpClientTest {

    private WebsiteHealthHttpClient service;

    @BeforeEach
    public void setup() {
        service = new WebsiteHealthHttpClient();
    }

    @Test
    void callbackVersionShouldReturnOk() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);  //카운트(작업)를 1로 초기화

				//결과가 오면 실행될 람다(콜백)전달
        service.isWebsiteAliveWithCallback(result -> {
            try {
                assertThat(result.success()).isTrue();
                assertThat(result.status()).isEqualTo("ok");
            } finally {
                latch.countDown();   //테스트 종료 신호 (카운트 1 감소)
            }
        });

        // 10초 안에 결과 안 오면 실패 처리
        boolean completed = latch.await(10, TimeUnit.SECONDS); // 카운트가 0이 될 때까지 현재 스레드를 대기
        assertThat(completed).isTrue();
    }
}
```

→ 콜백 함수가 종료점인 함수를 테스트하려면 직접 작성한 콜백 함수를 전달해야함.

→ latch.await 를 통해 카운트가 0이 될때까지 스레드 블로킹해 테스트가 끝났음을 알 수 있음

- `CountDownLatch`
    - 특정 수의 작업이 완료될 때까지 메인 스레드(또는 다른 스레드)를 기다리게 만드는 동기화 장치
    - `new CountDownLatch(1)`: 카운트를 1로 초기화
    - `latch.countDown()`: 카운트를 1 감소
    - `latch.await()`: 카운트가 0이 될 때까지 현재 스레드를 대기
        - 테스트에서는 타임아웃을 설정하여 무한 대기를 방지

### 6.1.2 작업 기다리기

---

6-2 예제에서는 콜백을 종료점으로 사용하기 때문에 테스트는 병렬 실행이 완료될 때까지 명시적으로 기다려야 됨

jest 에서는 done() 를 호출해 기다리지만

junit 자체에는 비동기 콜백을 직접 받는 구조가 없음.

아래 방식을 써서 테스트 스레드가 기다릴 수 있게 만들어줘야 됨

- 콜백에서 `countDown()`, 테스트 본문에서 `latch.await()`를 사용해 기다림

### 6.1.3   async/await를 사용하는 통합 테스트

---

예제 6-4 콜백과 .thenAccept() 을 이용한 통합 테스트

```java
@Test
void asyncAwaitVersionShouldReturnOkWithThenAccept() throws Exception {
    CountDownLatch latch = new CountDownLatch(1);

    service.isWebsiteAliveWithAsyncAwait()
            .thenAccept(result -> {
                try {
                    assertThat(result.success()).isTrue();
                    assertThat(result.status()).isEqualTo("ok");
                } finally {
                    latch.countDown();
                }
            });

    boolean completed = latch.await(10, TimeUnit.SECONDS);
    assertThat(completed).isTrue();
}
```

→ 이전 테스트와 거의 동일

[차이점]

- CompletableFuture 를 콜백방식으로 사용함
- 반환된 Future에 `.thenAccept()`를 사용하여 결과가 준비되었을 때 실행할 콜백을 등록
- isTrue() -> isFalse() 바꾼 후 테스트시 통과?
    
    ```java
    @Test
    void asyncAwaitVersionShouldReturnOkWithThenAccept() throws Exception {
        CountDownLatch latch = new CountDownLatch(1);
    
        service.isWebsiteAliveWithAsyncAwait()
                .thenAccept(result -> {
                    try {
                        assertThat(result.success()).isFalse(); //isTrue() -> isFalse()
                        assertThat(result.status()).isEqualTo("ok");
                    } finally {
                        latch.countDown();
                    }
                });
    
        boolean completed = latch.await(10, TimeUnit.SECONDS);
        assertThat(completed).isTrue();
    }
    ```
    
    ![image.png](6%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%EC%BD%94%EB%93%9C%20%EB%8B%A8%EC%9C%84%20%ED%85%8C%EC%8A%A4%ED%8A%B8%2025a747dafe1780c4baa0c8be21a71213/image%201.png)
    
    > Assertion 실패가 Junit이 감시하는 메인 테스트 스레드가 아닌, 별도의 백그라운드 스레드에서 발생함
    > 
    > 
    > → 메인 테스트 스레드는 실패 여부를 판단할 수 없어서 생기는 문제..
    > 
    
    1. service.isWebsiteAliveWithAsyncAwait().thenAccept() 호출
    2. thenAccept 안의 람다함수는 HttpClient 가 관리하는 별도의 백그라운드 스레드에서 실행됨
    3. assertThat(result.success()).isFalse(); 는  result.success() = true 이므로 AssertionError를 발생 시킴 → 백그라운드 스레드에서 에러 터짐
    4. finally 실행
    5. 메인 테스트 스레드는 `latch.await(...)` 대기하고 있다가 `latch.countDown()`이 호출되자마자 깨어남
    
     
    
    [해결]
    
    1. **예외를 메인 테스트 스레드로 가져오기**
    - 백그라운드 스레드에서 발생한 예외를 변수에 저장해두었다가, 메인 스레드에서 확인
    - `code`
        
        ```java
        @Test
        void asyncAwaitVersionShouldReturnOkWithThenAccept() throws Exception {
            CountDownLatch latch = new CountDownLatch(1);
            // 발생한 예외를 저장할 컨테이너 (스레드-안전해야 함)
            final AtomicReference<Throwable> exceptionHolder = new AtomicReference<>();
        
            service.isWebsiteAliveWithAsyncAwait()
                    .thenAccept(result -> {
                        try {
                            assertThat(result.success()).isFalse(); // 여기서 에러 발생!
                            assertThat(result.status()).isEqualTo("ok");
                        } catch (Throwable t) {
                            exceptionHolder.set(t); // 에러를 컨테이너에 저장
                        } finally {
                            latch.countDown();
                        }
                    });
        
            boolean completed = latch.await(10, TimeUnit.SECONDS);
            assertThat(completed).isTrue();
        
            // 메인 스레드에서 저장된 예외가 있는지 확인
            if (exceptionHolder.get() != null) {
                throw exceptionHolder.get(); // 예외가 있다면 던져서 테스트를 실패시킴
            }
        }
        ```
        
    
    1. **.join() 을 사용하여 테스트를 동기식으로 만들기 → 예제 6-4**
    - `.join()` 예외 전파 방식
        1. 백그라운드 스레드에서 예외발생
        2. `CompletableFuture`에 예외 기록: 자신의 상태를 비정상완료로 바꾸고, 
            
            발생한 Exception을 저장
            
        3. 메인 테스트 스레드에서 `join()` 호출: 메인 스레드가 해당 `CompletableFuture` 객체의 `join()`을 호출
        4. `join()` 메소드는 `CompletableFuture`의 내부 상태를 확인
        5. 정상 완료시 → 저장된 결과 값을 그대로 반환
        6. 비정상 완료시 → 내부에 저장해두었던 원래 예외를 꺼내 `CompletionException`이라는 새로운 언체크 예외로 감싸 스레드로 던짐
        

예제 6-4 async/await를 사용한  통합 테스트

```java
  @Test
  void asyncAwaitVersionShouldReturnOkWithJoin() {
      var result = service.isWebsiteAliveWithAsyncAwait().join();
      assertThat(result.success()).isTrue();
      assertThat(result.status()).isEqualTo("ok");
  }
```

[과정]

- isWebsiteAliveWithAsyncAwait() 를 호출하여 Future을 받은뒤, 곧바로 .join() 메서드를 호출
- .join() 은 작업이 완료될 때까지 현재 스레드를 블로킹함 → 완료시 결과 반환

→ join() 를 쓰면 테스트가 거의 일반 동기 테스트처럼 단순해짐.

→ AAA 패턴에 맞추기 쉽다.

→ 진입점이 곧 종료점이 됨.

하지만 겉모습만 동기일뿐, 본질은 여전히 비동기이다.

- `.get() , .join()` → CompletableFuture 의 결과를 동기적으로 꺼내는 메서드
    - `get()`: 체크 예외(InterruptedException, ExecutionException)를 던짐 → try-catch 나 throws 선언 필요
    - `join()`: 언체크 예외(CompletionException)로 감싸서 던짐 → 코드가 간결해짐.
        - `CompletionException` 은 `RuntimeException` 의 하위 클래스이므로, 호출하는 쪽에서 try-catch 를 강제로 작성할 필요가 없음

### 6.1.4 통합테스트의 어려움

---

1. **긴 실행 시간**
    - 단위 테스트보다 훨씬 느림. 몇 초~몇 분 걸릴 수도 있음.
    - 외부 API, DB, 네트워크 I/O까지 포함되기 때문.
    
2. **불안정성 (Flakiness)**
    - 실행 환경에 따라 성공/실패가 달라질 수 있음.
    - 네트워크 지연, 외부 서버 상태 등에 영향을 받아 일관성 없는 결과 발생.
    
3. **테스트와 무관한 환경 검증**
    - 애플리케이션 코드 자체와 무관한 문제까지 노출됨.
    - 예: 라이브러리 버그, 방화벽, 외부 웹 사이트 상태 같은 요소.
    
4. **문제 파악에 많은 시간이 걸림**
    - 실패했을 때 원인이 다양 → 코드인지, 네트워크인지, 외부 서버인지 알기 어려움.
    - 디버깅에 많은 시간 소모.
    
5. **상황을 재현하기 어려움**
    - 외부 요인 때문에 발생한 실패를 로컬/테스트 환경에서 그대로 재현하기 힘듦.
    - 네트워크 다운, 특정 시점의 웹 컨텐츠 등.
    
6. **결과 신뢰성 부족**
    - 외부 문제라고 생각했는데 실제로는 코드 버그일 수 있음.

→ 통합테스트가 별로가 아님. 코드 신뢰성을 높이려고 너무 많은 통합 테스트를 작성할 필요는 없다는 말

통합 테스트로 채울 수 없는 부분은 단위 테스트나 API 테스트, 컴포넌트 테스트 같은 하위 수준의 테스트로 

채우면 됨

## 6.2 코드를 단위 테스트에 적합하게 만들기

---

테스트하기 쉽게 하기 위해서는 의존성을 주입하거나 의존성 자체를 피할 수 있어야됨

이떄 흔히 쓰이는 **두 가지 패턴**

1. **진입점 분리 패턴**
- 프로덕션 코드에서 순수 로직 부분을 별도의 함수로 분리하여 그 함수를 테스트의 시작점으로 사용하는 패턴

1. **어댑터 분리 패턴** 
- 본질적으로 비동기적인 요소를 분리하고 이를 추상화하여 동기적인 요소로 대체할 수 있게 하는 패턴

### 6.2.1 진입점 분리 패턴

---

 진입점 분리 패턴 개념

- 비동기 작업을 두 부분으로 나눈다:
    1. 비동기 부분 (예: 네트워크 호출, DB 접근 등) → 그대로 둠
    2. 비동기 결과를 처리하는 콜백/로직 부분 → 별도 함수로 분리
    
    → “결과를 받아서 처리하는 순수 로직”을 별도의 함수로 빼내서, 그 함수를 단위 테스트의 진입점(entry point) 으로 사용한다.
    

![image.png](6%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%EC%BD%94%EB%93%9C%20%EB%8B%A8%EC%9C%84%20%ED%85%8C%EC%8A%A4%ED%8A%B8%2025a747dafe1780c4baa0c8be21a71213/image%202.png)

1단계. 비동기 작업 결과를 처리하는 로직을 별도의 함수로 분리함

2단계.분리된 함수를 외부에 노출시켜 단위 테스트의 진입점으로 사용할 수 있게함

→ 외부 의존성 없이 동기적으로 새로운 작업 단위를 검증할 수 있음 

****진입점 분리 패턴을 쓰면 얻는 효과

- 비동기 콜백 로직을 쉽게 테스트 가능
- 상위 수준의 통합 테스트로 보완
- 속도 + 유지보수성 + 신뢰성 확인

### 작업 단위 분리 예제

---

1.  기존 상태: isWebsiteAlive() 함수에 로직이 포함 (네트워크 호출 + 처리 로직)
2. 네트워크 요청 결과가 처리되는 부분의 로직 코드를 분리
    - `processFetchSuccess` : 성공 케이스 처리
    - `processFetchError` : 오류 케이스 처리
3. 이 두 함수를 외부에 노출시켜 단위 테스트에서 직접 호출할 수 있게 함

![image.png](6%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%EC%BD%94%EB%93%9C%20%EB%8B%A8%EC%9C%84%20%ED%85%8C%EC%8A%A4%ED%8A%B8%2025a747dafe1780c4baa0c8be21a71213/image%203.png)

에제 6-5 **콜백을** 사용하여 진입점 분리하기

```java
package ch06.v2;

import ch06.v1.HealthResult;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.function.Consumer;

public class WebsiteHealthService {

    private final HttpClient client;
    private final String url = "http://example.com";

    public WebsiteHealthService() {
        this.client = HttpClient.newHttpClient(); // 기본 HttpClient
    }

    /** ------------------- 진입점 1 -------------------
     *  외부 호출 + 콜백 (비동기)
     */
    public void isWebsiteAlive(Consumer<HealthResult> callback) {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .GET()
                .build();

        client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
                .thenApply(this::throwOnInvalidResponse)  // 응답 검증
                .thenApply(HttpResponse::body)            // body 추출
                .thenAccept(body -> processFetchSuccess(body, callback)) // 성공 처리
                .exceptionally(err -> { // 오류 처리
                    processFetchError(err, callback);
                    return null;
                });
    }

		//상태 코드 검증 메서드
    private HttpResponse<String> throwOnInvalidResponse(HttpResponse<String> resp) {
        if (resp.statusCode() / 100 != 2) {
            throw new RuntimeException("HTTP " + resp.statusCode());
        }
        return resp;
    }

    /** ------------------- 진입점 2 -------------------
     *  성공 로직만 따로 분리 (순수 함수)
     */
    public void processFetchSuccess(String text, Consumer<HealthResult> callback) {
        if (text.contains("illustrative")) {
            callback.accept(new HealthResult(true, "ok"));
        } else {
            callback.accept(new HealthResult(false, "missing text"));
        }
    }

    /** ------------------- 진입점 3 -------------------
     *  오류 로직만 따로 분리 (순수 함수)
     */
    public void processFetchError(Throwable err, Consumer<HealthResult> callback) {
        callback.accept(new HealthResult(false, err.getMessage()));
    }
}
```

3가지 진입점 

1. isWebsiteAlive(callback) 함수
2. processFetchSuccess, processFetchError 함수, 비동기 작업의 성공 실패 여부 처리
    
    ![image.png](6%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%EC%BD%94%EB%93%9C%20%EB%8B%A8%EC%9C%84%20%ED%85%8C%EC%8A%A4%ED%8A%B8%2025a747dafe1780c4baa0c8be21a71213/image%204.png)
    

예제 6-6 분리된 진입점을 사용한 단위테스트

```java
package ch06.v2;

import static org.junit.jupiter.api.Assertions.*;

import ch06.v1.HealthResult;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import org.junit.jupiter.api.Test;

class WebsiteHealthServiceTest {

    @Test
    void contentMatches_returnsTrue() throws Exception {
        WebsiteHealthService service = new WebsiteHealthService(); 

        CountDownLatch latch = new CountDownLatch(1);
        AtomicReference<HealthResult> ref = new AtomicReference<>(); //콜백이 넘겨준 객체 담는 컨테이너

        service.processFetchSuccess("illustrative", result -> {
            ref.set(result);
            latch.countDown();
        });

        assertTrue(latch.await(2, TimeUnit.SECONDS), "콜백이 호출되지 않았습니다");

        HealthResult r = ref.get();
        assertNotNull(r);
        assertTrue(r.success());
        assertEquals("ok", r.status());
    }

    @Test
    void contentNotMatch_returnsFalse() throws Exception {
        WebsiteHealthService service = new WebsiteHealthService();

        CountDownLatch latch = new CountDownLatch(1);
        AtomicReference<HealthResult> ref = new AtomicReference<>();

        service.processFetchSuccess("bad content", result -> {
            ref.set(result);
            latch.countDown();
        });

        assertTrue(latch.await(2, TimeUnit.SECONDS), "콜백이 호출되지 않았습니다");

        HealthResult r = ref.get();
        assertNotNull(r);
        assertFalse(r.success());
        assertEquals("missing text", r.status());
    }

    @Test
    void whenFetchFails_returnsFalse() throws Exception {
        WebsiteHealthService service = new WebsiteHealthService();

        CountDownLatch latch = new CountDownLatch(1);
        AtomicReference<HealthResult> ref = new AtomicReference<>();

        service.processFetchError(new RuntimeException("error text"), result -> {
            ref.set(result);
            latch.countDown();
        });

        assertTrue(latch.await(2, TimeUnit.SECONDS), "콜백이 호출되지 않았습니다");

        HealthResult r = ref.get();
        assertNotNull(r);
        assertFalse(r.success());
        assertEquals("error text", r.status());
    }

}
```

새로운 진입점이 생기면서 이를 직접 호출(processFetchSuccess, processFetchError: 순수 로직 함수(진입점))하는 식으로 코드가 변경되었음

→ 빠르고 안정적인 단위 테스트 가능

하지만 완전히 통합 테스트를 없애면 안됨 

→ 콜백이 아예 안불리는 경우를 잡기 위해서는 필요

→ countDownLatch.await() 같은 것으로 끝까지 도는지 확인

### await를 사용한 진입점 분리

---

![image.png](6%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%EC%BD%94%EB%93%9C%20%EB%8B%A8%EC%9C%84%20%ED%85%8C%EC%8A%A4%ED%8A%B8%2025a747dafe1780c4baa0c8be21a71213/image%205.png)

예제 6-7 CompletableFuture 기반 비동기 메서드

```java
package ch06.v3;

import ch06.v1.HealthResult;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.concurrent.CompletableFuture;

public class WebsiteHealthService {

    private final HttpClient client;
    private final String url = "http://example.com";

    public WebsiteHealthService() {
        this.client = HttpClient.newHttpClient();
    }

    /** ------------------- 진입점 1 -------------------
     *  외부 호출 (비동기, async/await 대응)
     */
    public CompletableFuture<HealthResult> isWebsiteAlive() {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .GET()
                .build();

        return client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
                .thenApply(this::throwIfResponseNotOK)        // 응답 검증
                .thenApply(HttpResponse::body)                // body 추출
                .thenApply(this::processFetchContent)         // 성공 처리
                .exceptionally(this::processFetchError);      // 오류 처리
    }

    /** ------------------- 진입점 2 -------------------
     *  응답 검증 (2xx 아니면 예외)
     */
    private HttpResponse<String> throwIfResponseNotOK(HttpResponse<String> resp) {
        if (resp.statusCode() / 100 != 2) {
            throw new RuntimeException("HTTP " + resp.statusCode());
        }
        return resp;
    }

    /** ------------------- 진입점 3 -------------------
     *  성공 로직
     */
    private HealthResult processFetchContent(String text) {
        if (text != null && text.contains("illustrative")) {
            return new HealthResult(true, "ok");
        }
        return new HealthResult(false, "missing text");
    }

    /** ------------------- 진입점 4 -------------------
     *  오류 처리 (예외 -> HealthResult 변환)
     */
    private HealthResult processFetchError(Throwable err) {
        return new HealthResult(false, err.getMessage());
    }

}
```

예제 6-8 분리된 진입점 테스트하기

```java
package ch06.v3;

import static org.junit.jupiter.api.Assertions.*;

import ch06.v1.HealthResult;
import org.junit.jupiter.api.Test;

class WebsiteHealthServiceTest {

    @Test
    void onFetchSuccessWithGoodContentReturnsTrue() {
        WebsiteHealthService service = new WebsiteHealthService();

        HealthResult result = service.processFetchContent("illustrative");

        assertTrue(result.success());
        assertEquals("ok", result.status());
    }

    @Test
    void onFetchSuccessWithBadContentReturnsFalse() {
        WebsiteHealthService service = new WebsiteHealthService();

        HealthResult result = service.processFetchContent("text not on site");

        assertFalse(result.success());
        assertEquals("missing text", result.status());
    }

    @Test
    void onFetchFailReturnsHealthResultWithErrorMessage() {
        WebsiteHealthService service = new WebsiteHealthService();
        HealthResult result = service.processFetchError(new RuntimeException("error text"));

        assertFalse(result.success());
        assertEquals("error text", result.status());
    }
}
```

로직 작업 단위를 비동기 부분과 분리 했기 때문에 단위 테스트에서 비동기 대기를 신경쓸 필요가 없음

### 6.2.2 어댑터 분리 패턴

---

**어댑터 분리 패턴 vs 진입점 분리 패턴**

진입점 분리 패턴 - 외부 호출과 결과 처리 로직(순수 함수)를 분리

- 분리된 순수 로직 함수를 동기적으로 직접 호출

어댑터 분리 패턴 - 비동기 코드를 의존성처럼 여기는 전략

- 논리 코드를 별도의 진입점으로 분리하는 대신 기존 코드에서는 의존성으로 있던 비동기 코드를 분리하여 어댑터로 감싸고, 이를 다른 의존성처럼 주입할 수 있게함

![image.png](6%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%EC%BD%94%EB%93%9C%20%EB%8B%A8%EC%9C%84%20%ED%85%8C%EC%8A%A4%ED%8A%B8%2025a747dafe1780c4baa0c8be21a71213/image%206.png)

![image.png](6%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%EC%BD%94%EB%93%9C%20%EB%8B%A8%EC%9C%84%20%ED%85%8C%EC%8A%A4%ED%8A%B8%2025a747dafe1780c4baa0c8be21a71213/image%207.png)

<aside>

인터페이스 분리 원칙

---

인터페이스 분리 원칙(ISP)은 클라이언트가 자신이 사용하지 않는 메서드에 의존하지 않도록, 

인터페이스를 작고 구체적으로 나누라는 원칙

</aside>

예제 6-9 네트워크 어댑터 코드

```java
package ch06.v4;

import ch06.v1.HealthResult;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.concurrent.CompletableFuture;

public class NetworkAdapter {
    private final HttpClient client;

    public NetworkAdapter() {
        this.client = HttpClient.newHttpClient();
    }

    public CompletableFuture<HealthResult> fetchUrlText(String url) {
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .GET()
                .build();

        return client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
                .thenApply(resp -> {
                    if (resp.statusCode() / 100 == 2) {
                        return new HealthResult(true, resp.body());
                    } else {
                        return new HealthResult(false, resp.statusCode() + " " + resp.body());
                    }
                });
    }

}
```

예제 6-10 네크워크 어댑터 모듈을 사용하는 isWebsiteAlive() 함수

```java
package ch06.v4;

import ch06.v1.HealthResult;
import java.util.concurrent.CompletableFuture;

public class WebsiteHealthService {

    private final NetworkAdapter network;

    public WebsiteHealthService(NetworkAdapter network) {
        this.network = network;
    }

    /**
     * ------------------- 진입점 1 -------------------
     */
    public CompletableFuture<HealthResult> isWebsiteAlive() {
        return network.fetchUrlText("http://example.com")
                .thenApply(result -> {
                    if (!result.success()) {
                        throw new RuntimeException(result.status());
                    }
                    return processFetchSuccess(result.status());
                })
                .exceptionally(err -> processFetchFail(err.getMessage()));
    }

    /**
     * ------------------- 진입점 2 ------------------- 성공 처리
     */
    private HealthResult processFetchSuccess(String text) {
        if (text != null && text.contains("illustrative")) {
            return new HealthResult(true, "ok");
        }
        return new HealthResult(false, "missing text");
    }

    /**
     * ------------------- 진입점 3 ------------------- 실패 처리
     */
    private HealthResult processFetchFail(String err) {
        return new HealthResult(false, err);
    }

}
```

- 네트워크 어댑터 모듈을 가져옴
    
    → 추후에 테스트에서 가짜 모듈로 대체할 예정
    

예제 6-11 mockit를 사용하여 네트워크 어댑터를 가짜로 만들어 대체하기

```java
package ch06.v4;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.when;

import ch06.v1.HealthResult;
import java.util.concurrent.CompletableFuture;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class WebsiteHealthServiceTest {

    @Mock
    private NetworkAdapter network;

    @InjectMocks
    private WebsiteHealthService verifier;  // @Mock 된 필드를 주입받음

    @Test
    void withGoodContentReturnsTrue() {
        // given: mock fetchUrlText → "illustrative"
        when(network.fetchUrlText("http://example.com"))
                .thenReturn(CompletableFuture.completedFuture(
                        new HealthResult(true, "illustrative")
                ));

        // when
        HealthResult result = verifier.isWebsiteAlive().join();

        // then
        assertTrue(result.success());
        assertEquals("ok", result.status());
    }

    @Test
    void withBadContentReturnsFalse() {
        // given: mock fetchUrlText → 다른 텍스트
        when(network.fetchUrlText("http://example.com"))
                .thenReturn(CompletableFuture.completedFuture(
                        new HealthResult(true, "<span>hello world</span>")
                ));

        // when
        HealthResult result = verifier.isWebsiteAlive().join();

        // then
        assertFalse(result.success());
        assertEquals("missing text", result.status());
    }
}
```

→ 네크워크 어댑터 모듈의 모의 객체로 대체

 프로덕션은 비동기(CompletableFuture)로, 테스트는 비동기 의존성을 동처럼 보이도록 해야함

### 함수형 어댑터

---

어댑터 모듈 설계는 동일하게 유지됨

모듈을 NetworkVerifier 에 주입하는 방식이 달라짐 

예제 6-12 isWebsiteAlive()의 함수 주입 설계하기

- `NetworkAdapter`
    
    ```java
    package ch06.v6;
    
    import ch06.v1.HealthResult;
    import java.util.concurrent.CompletableFuture;
    
    @FunctionalInterface
    public interface NetworkAdapter {
        CompletableFuture<HealthResult> fetchUrlText(String url);
    }
    ```
    
- `HttpNetworkAdapter`
    
    ```java
    package ch06.v6;
    
    import ch06.v1.HealthResult;
    import java.net.URI;
    import java.net.http.HttpClient;
    import java.net.http.HttpRequest;
    import java.net.http.HttpResponse;
    import java.util.concurrent.CompletableFuture;
    
    public class HttpNetworkAdapter implements NetworkAdapter {
        private final HttpClient client;
    
        public HttpNetworkAdapter() {
            this.client = HttpClient.newHttpClient();
        }
    
        public CompletableFuture<HealthResult> fetchUrlText(String url) {
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(url))
                    .GET()
                    .build();
    
            return client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
                    .thenApply(resp -> {
                        if (resp.statusCode() / 100 == 2) {
                            return new HealthResult(true, resp.body());
                        } else {
                            return new HealthResult(false, resp.statusCode() + " " + resp.body());
                        }
                    });
        }
    
    }
    
    ```
    

```java
package ch06.v6;

import ch06.v1.HealthResult;
import java.util.concurrent.CompletableFuture;

public class WebsiteVerifierFunctionalInjection {
    public CompletableFuture<HealthResult> isWebSiteAlive(NetworkAdapter network) {
        return network.fetchUrlText("https://example.com")
                .thenApply(result -> {
                    if (result.success()) {
                        String text = result.status();
                        return onFetchSuccess(text);
                    }
                    return onFetchError(result.status());
                });
    }

    private HealthResult onFetchSuccess(String text) {
        return text.contains("illustrative")
                ? new HealthResult(true, "ok")
                : new HealthResult(false, "missing text");
    }

    private HealthResult onFetchError(String err) {
        return new HealthResult(false, err);
    }
}

```

→ 네크워크 어댑터 모듈이 함수의  매개변수로 주입되도록 만듬

→ 네크워크 어댑터 모듈을 더 이상 가져오지 않음

+ `@ExtendWith(MockitoExtension.class)`를 쓰면, 각 테스트 메서드 실행 전에 `@Mock` 객체들이 자동으로 초기화됨

예제 6-13 함수형 주입을 사용한 네트워크 어댑터 단위 테스트

```java
package ch06.v6;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import ch06.v1.HealthResult;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import org.junit.jupiter.api.Test;

class WebsiteVerifierFunctionalInjectionTest {

    private NetworkAdapter makeStubNetworkWithResult(HealthResult fakeResult) {
        return url -> CompletableFuture.completedFuture(fakeResult);
    }

    @Test
    void withGoodContent_returnsTrue() throws Exception {
        NetworkAdapter stubSyncNetwork = makeStubNetworkWithResult(
                new HealthResult(true, "illustrative"));

        WebsiteVerifierFunctionalInjection verifier = new WebsiteVerifierFunctionalInjection();
        HealthResult result = verifier.isWebSiteAlive(stubSyncNetwork).get(1, TimeUnit.SECONDS);

        assertTrue(result.success());
        assertEquals("ok" , result.status());
    }

    @Test
    void withBadContent_returnsFalse() throws Exception {
        NetworkAdapter stubAsyncNetwork = makeStubNetworkWithResult(
                new HealthResult(true, "unexcepted content"));

        WebsiteVerifierFunctionalInjection verifier = new WebsiteVerifierFunctionalInjection();
        HealthResult result = verifier.isWebSiteAlive(stubAsyncNetwork).get(1, TimeUnit.SECONDS);

        assertFalse(result.success());
        assertEquals("missing text" , result.status());
    }

    @Test
    void withFetchErrors_returnFalse_onMessage() throws Exception {
        NetworkAdapter stubAsyncNetwork = makeStubNetworkWithResult(
                new HealthResult(false, "network error"));

        WebsiteVerifierFunctionalInjection verifier = new WebsiteVerifierFunctionalInjection();
        HealthResult result = verifier.isWebSiteAlive(stubAsyncNetwork).get(1, TimeUnit.SECONDS);

        assertFalse(result.success());
        assertEquals("network error" , result.status());
    }
}
```

- 모듈형 디자인과 달리 테스트 클래스 위쪽에 보일플레이트 코드가 거의 필요 없다는 것을 알 수 있음
    - @ExtendWith(MockitoExtension.class)
    - @Mock, @InjectMock
- Mockito를 이용해 모듈을 간접적으로 페이크(mock)으로 만들 필요도 없음
- 대신 가짜 NetworkAdapter를 생성하면됨

→ 프레임워크 의존을 줄이고, 순수 자바 코드 만으로도 네트워크 계층을 대체하여 테스트를 작성할 수 있다는 장점이 있음

### 객체 지향, 인터페이스 기반 어댑터

---

[위와 동일](https://www.notion.so/6-25a747dafe1780c4baa0c8be21a71213?pvs=21)

제어의 반전, 의존성 주입 방식은 매우 효과적임.

객체 지향 프로그래밍에서 인터페이스를 사용한 생성자 주입 방식은 매우 일반적이며, 

여러 상황에서 의존성 로직과 분리하여 유지 관리가 쉬운 유효 방식일 수 있음.

## 6.3 타이머 다루기

---

자바에는 setTimeout, setIntervval 같은 브라우저 타이머 API는 없음

- setTimeout의 역할(JavaScript)
    
    <aside>
    
    - setTimeout(fn, ms)는 ms 밀리터 뒤에 fn 함수를 실행해줘라는 예약
    - JS 런타임(브라우저/Node)이 비동기 이벤트 루프를 돌면서 ms 시간이 지나면
        
        콜백 함수를 실행해줌
        
    </aside>
    

대신 자바쪽에서는 스레드, 스케줄링, 시간 API 로 타이머 기능을 제공함.

- 예시
    
    <aside>
    
    1. Thread.sleep()
    - 가장 기본적인 타이머 대체
    - 지정한 시간(ms) 동안 현재 스레드를 멈춤
        
        ```java
        Thread.sleep(1000); // 1초 대기
        ```
        
    
    1. java.util.Timer + TimeTask
    - 예전부터 있었던 클래스
    - 특정 시간 후 또는 주기적으로 실행할 수 있음
        
        ```java
        Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println("1초 후 실행!");
            }
        }, 1000); // 1초 후 실행
        ```
        
        → 단점: 오래된 API, 스레드 관리가 불편 → 안씀
        
    
    3. ScheduledExecutorService
    
    - 현대적인 방식
    - 여러 작업을 스레드 풀에서 스케쥴링 가능
        
        ```java
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        
        scheduler.schedule(() -> {
            System.out.println("2초 후 실행!");
        }, 2, TimeUnit.SECONDS);
        
        scheduler.scheduleAtFixedRate(() -> {
            System.out.println("1초마다 실행!");
        }, 0, 1, TimeUnit.SECONDS);
        ```
        
    
    4. CompletableFuture**.**delayedExecutor(...)
    
    - Java9부터 추가된 비동기 방식
    - Future/Promise 스타일로 딜레이 가능
        
        ```java
        CompletableFuture.runAsync(
            () -> System.out.println("3초 후 실행!"),
            CompletableFuture.delayedExecutor(3, TimeUnit.SECONDS)
        );
        ```
        
    </aside>
    

자바에서 시간을 제어하는 예시의 테스트 제어 두 가지 방식

1. 시간 소스 추상화(TimeProvider, Clock) → 테스트에서 가짜 시간 주입
2. 스케줄링 프레임워크(scheduledExecutorService, Awaitility) → 타이머 자체를 제어

### 6.3.1 시간 소스 추상화해서 의존성을 주입해주는 방식

---

- js 에서는 함수를 직접 몽키 패칭한다고 하는데 몽키 패칭이 뭘까?
    
    <aside>
    
    몽키패칭 (monkey patching)
    
    ---
    
    - 실행중(runtime)에 기존 코드(클래스, 함수, 모듈)의 동작을 바꾸거나 확장하는 것을 말함
    - 즉, 원본을 건드리지 않고 덮어씌우는 것??
        
        ```java
        // 원래 setTimeout
        const originalSetTimeout = setTimeout;
        
        // 몽키 패칭: setTimeout을 가짜로 덮어씀
        global.setTimeout = (fn, ms) => {
          console.log(`Fake timer! Wait ${ms}ms`);
          return originalSetTimeout(fn, 0); // 강제로 즉시 실행
        };
        ```
        
        → 코드 전체에서 setTimeout의 동작이 바뀜
        
    </aside>
    

<aside>

그럼 왜 자바에서는 몽키패칭이 안될까?

---

**자바는 정적 타입 언어 + 강한 캡슐화를 지향**

런타임에 클래스나 메서드 자체를 덮어쓰기 할 수 없음

</aside>

→ 자바에서는 대안으로 시간을 추상화해 의존성을 주입해주는 방식을 사용할 것임

예제 6-17 시간 클래스

- `TimeProvider`
    
    ```java
    package ch06.timer.v1;
    
    @FunctionalInterface
    public interface TimeProvider {
        void setTimeout(Runnable task, long milliseconds);
    }
    ```
    
- `RealTimeProvider`
    
    ```java
    package ch06.timer.v1;
    
    import java.util.concurrent.Executors;
    import java.util.concurrent.ScheduledExecutorService;
    import java.util.concurrent.TimeUnit;
    
    public class RealTimeProvider implements TimeProvider {
        private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
    
        @Override
        public void setTimeout(Runnable task, long delayMillis) {
            scheduler.schedule(task, delayMillis, TimeUnit.MILLISECONDS);
        }
    }
    ```
    
- `Calculator`
    
    ```java
    package ch06.timer.v1;
    
    import java.util.function.Consumer;
    
    public class Calculator {
        private final TimeProvider timeProvider;
    
        public Calculator(final TimeProvider timeProvider) {
            this.timeProvider = timeProvider;
        }
    
        public void calculator1(int x, int y, Consumer<Integer> callback) {
            timeProvider.setTimeout(() -> callback.accept(x + y), 5000);
        }
    }
    ```
    

예제 6-18 테스트 

```java
package ch06.timer.v1;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

class CalculatorTest {

    @Test
    void test() {
        TimeProvider timeProvider = new TestTImeProvider();
        Calculator calculator = new Calculator(timeProvider);

        calculator.calculator1(1, 2, result -> {
            Assertions.assertEquals(3, result);
        });

    }
}
```

**→ TimeProvider 의존성 주입으로 TestTimeProvider() 을 주입시켜 테스트를 진행함**

- TestTimeProvider 클래스 주입으로 RealTimeProvider 클래스의  setTimeout 두번째 매개변수인ms 는 더 이상 사용되지 않고 콜백 함수는 즉시 실행됨

단점 

- 많은 보일러 플레이트 코드가 필요함

### 6.3.2 제스트로 setTimeout 대체하는거 자바로 흉내내기

---

- `TimeProvider`
    
    ```java
    package ch06.timer.v2;
    
    import ch06.timer.v1.TimeProvider;
    import java.util.ArrayList;
    import java.util.List;
    
    public class FakeScheduler implements TimeProvider {
        private final List<Runnable> scheduledTasks = new ArrayList<>();
    
        @Override
        public void setTimeout(Runnable task, long delayMillis) {
            scheduledTasks.add(task); // 실행은 보류
        }
    
        // Jest의 advanceTimersToNextTimer() 역할
        public void advanceTime() {
            for (Runnable task : scheduledTasks) {
                task.run(); // 저장된 작업 실행
            }
            scheduledTasks.clear();
        }
    
        // Jest의 resetAllTimers() 역할
        public void clearAll() {
            scheduledTasks.clear();
        }
    }
    ```
    
- `CalculatorTest`
    
    ```java
    package ch06.timer.v2;
    
    import ch06.timer.v1.Calculator;
    import org.junit.jupiter.api.BeforeEach;
    import org.junit.jupiter.api.Test;
    
    import static org.junit.jupiter.api.Assertions.assertEquals;
    
    public class CalculatorTest {
    
        private FakeScheduler fakeScheduler;
        private Calculator calculator;
    
        @BeforeEach
        void setup() {
            fakeScheduler = new FakeScheduler();
            calculator = new Calculator(fakeScheduler);
        }
    
        @Test
        void testCalculate1_withFakeScheduler() {
            calculator.calculator1(1, 2, result -> {
                assertEquals(3, result);
            });
    
            fakeScheduler.advanceTime();
        }
    }
    ```
    

## 6.4 일반적인 이벤트 처리

---

### 6.4.1 이벤트 이미터

---

> 이벤트 이미터(Event Emiter) 란?
> 
> 
> 이벤트(Event)를 발생시키고, 그 이벤트를 다른 코드가 구독(listen)해서 반응할 수 있게 해주는 패턴 
> 

자바에서의 이미터?

- Java 표준에는 Observer 패턴/Listener 패턴으로 구현하거나
- `@ApplicationEventPublisher`(이벤트 발행), `@EventListener`(리스너) 사용함

예제 6-22 이벤트 이미터 기반의 간단한 Adder 클래스

- `AdderListener`
    
    ```java
    package ch06.emitter.observer;
    
    public interface AdderListener {
        void onAdded(int result);
    }
    ```
    

```java
package ch06.emitter.observer;

import java.util.ArrayList;
import java.util.List;

public class Adder {
    private final List<AdderListener> listeners = new ArrayList<>();
    
    public void addListener(AdderListener listener) {
        listeners.add(listener);
    }
    
    public int add(int x, int y) {
        int result = 0;
        emitAdded(result);
        return result;
    }
    
    private void emitAdded(int result) {
        for (AdderListener listener : listeners) {
            listener.onAdded(result);
        }
    }
}
```

- `ApplicationEventPublisher` 으로 구현하기
    - `AddedEvent`
        
        ```java
        package ch06.emitter.v1;
        
        public class AddedEvent {
            private final int result;
        
            public AddedEvent(int result) {
                this.result = result;
            }
        
            public int getResult() {
                return result;
            }
        }
        ```
        
    
    ```java
    package ch06.emitter.v1;
    
    import org.springframework.context.ApplicationEventPublisher;
    import org.springframework.stereotype.Component;
    
    @Component
    public class Adder {
        private final ApplicationEventPublisher publisher;
    
        public Adder(ApplicationEventPublisher eventPublisher) {
            this.publisher = eventPublisher;
        }
    
        public int add(int x, int y) {
            int result = x + y;
            publisher.publishEvent(new AddedEvent(result));  //이벤트 발행
            return result;
        }
    }
    ```
    
    ```java
    package ch06.emitter.v1;
    
    import org.springframework.context.event.EventListener;
    import org.springframework.stereotype.Component;
    
    @Component
    public class AdderEventHandler {
    
        @EventListener
        public void handleAdd(AddedEvent event) {
            System.out.println("이벤트 수신:" + event.getResult());
        }
    }
    ```
    
    - 실행과정
        - publishEvent(new AddedEvent(5)) 실행이되면
        - SimpleApplicationEventMuticaster 가 AddedEvent를 받고,
            - @EventListener(AddedEvent) 달린 AdderEventHandler.onAdded() 메소드 탐색.
        - 해당 메서드 호출  →  “이벤트 수신: {event.getResult()} “ 호출

예제 6-23 이벤트를 구독하여 이벤트 테스트하기

해당 이벤트를 구독하고 add 함수를 호출할 때 이벤트가 발생하는지 확인하기

```java
package ch06.emitter.v1;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

import java.util.concurrent.atomic.AtomicInteger;
import org.junit.jupiter.api.Test;

public class AdderTest {

    @Test
    void generatesAdditionEventWhenCalled() {
        // given
        Adder adder = new Adder();
        AtomicInteger capturedResult = new AtomicInteger();

        // 이벤트 구독
        adder.addListener(result -> capturedResult.set(result));

        // when
        int returnValue = adder.add(1, 2);

        // then (add의 반환값 검증)
        assertThat(returnValue).isEqualTo(3);

        // and (이벤트 리스너가 받은 값 검증)
        assertThat(capturedResult.get()).isEqualTo(3);
    }
}
```

### 6.4.2 클릭 이벤트 처리

---

UI 이벤트중 클릭 이벤트가 제대로 바인딩되었는지 스크립트를 사용해서 테스트한다.

```java
package ch06.click;

import javax.swing.*;

public class ClickExample {
    private final JButton button;
    private final JLabel resultLabel;

    public ClickExample() {
        this.button = new JButton("Click Me!");
        this.resultLabel = new JLabel("Waiting...");

        // JS의 window.onload → 초기 상태
        resultLabel.setText("Document Loaded");

        // JS의 addEventListener("click", cb)
        button.addActionListener(e -> resultLabel.setText("Clicked!"));
    }

    public JButton getButton() {
        return button;
    }

    public JLabel getResultLabel() {
        return resultLabel;
    }
}
```

두 가지의 테스트 방법

1. 그다지 좋지 않은 방법
    - 클릭 이벤트를 구독하고 실제 이벤트가 발생했는지 확인하기
    
    → 큰 의미가 없음. 우리가 확인해봐야 할 것은 클릭이 실제로 어떤 작업을 수행했는지 여부임
    

1. 더 나은 방법
    - 클릭 이벤트를 직접 발생시켜 페이지 내부 값이 올바르게 변경되었는지 확인하기
        
        ![클릭을 진입점으로 하고 요소를 종료점으로 하는 과정](6%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%EC%BD%94%EB%93%9C%20%EB%8B%A8%EC%9C%84%20%ED%85%8C%EC%8A%A4%ED%8A%B8%2025a747dafe1780c4baa0c8be21a71213/image%208.png)
        
        클릭을 진입점으로 하고 요소를 종료점으로 하는 과정
        

예제 6-26 클릭 이벤트를 트리거하고 요소의 텍스트 테스트하기

```java
package ch06.emitter.v1;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

import ch06.click.ClickExample;
import org.junit.jupiter.api.Test;

public class AdderTest {
    @Test
    void buttonClickTriggersLabelChange() {
        // given: 컴포넌트 준비
        ClickExample example = new ClickExample();

        // document.load() 이벤트 → 초기 상태 검증
        assertThat(example.getResultLabel().getText())
                .isEqualTo("Document Loaded");

        // when: button.click()
        example.getButton().doClick();

        // then: resultDiv.innerText === "Clicked!"
        assertThat(example.getResultLabel().getText())
                .isEqualTo("Clicked!");
    }
}
```

## 6.6 요약

---

<aside>

비동기 코드를 직접 테스트하면 → 시간이 오래 걸리고 불안정해짐.

해결법: 진입점 분리 + 어댑터 분리

1. 진입점 분리

- 순수 로직을 함수로 분리
    - 테스트에서는 이 함수만 호출  → 결과값으로 검증
    - 콜백/반환값 사용 → 복잡성을 줄임

2. 어댑터 분리

- 본질적으로 비동기 의존성을 동기적으로 대체할 수 있도록 분리
- 유형
    - 모듈형: 모듈/파일 스텁으로 만들어 특정 함수를 대체
    - 함수형: 시스템에 입력되는 함수를 스텁으로 주입
    - 객체 지향형: 인터페이스로 추상화 → 테스트에서는 구현체를 스텁으로 제공

1. 타이머 처리

[JS]

- setTimeout, setInterval 같은 타이머는
    
    → 몽키 패칭 or 테스트 프레임워크 비활성화 기능으로 제어 가능
    

[Java]

- setTimeout 은 없지만, ScheduledExecutorService나 Timer 클래스를 사용함
    
    → 시간 소스 추상화로 대체함 
    

1. 이벤트 테스트

[JS]

- 가장 좋은 방법: 사용자에게 보이는 HTML 변경사항을 기준으로 검증
- DOM Testing Library 같은 라이브러리를 사용하거나 직접 DOM 조작

[Java]

- 자바에서는 Swing/JavaFx 이벤트 또는 Spring ApplicationEvent 같은 구조로 테스트
</aside>