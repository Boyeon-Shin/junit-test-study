# 5장. 격리 프레임워크

---

**이전 장.**

목과 스텁을 수동으로 직접 작성하는 방법을 살펴봄

가짜로 만들려는 인터페이스 복잡 → 인터페이스 구현하는 쪽에서 반복 코드가 많이 늘어남, 오류가 발생하기 쉬운 코드가 작성됨

**해결.**

격리 프레임워크 사용하기

격리 프레임워크 - 런타임에 가짜 객체를 생성하고 설정할 수 있는 재사용 가능한 라이브러리를 의미

**⇒ 동적 스텁(dynamic stub) 동적 목(dynamic mocks) 이라고 함**

프레임워크를 사용하면서 테스트의 가독성, 유지보수성, 지속 가능한 테스트 등 이 프레임워크들이 지향하는 가치를 배울 수 있음

## 5.1 격리 프레임워크 정의

---

> 격리 프레임워크란?
> 
> 
> 객체나 함수 형태의 목이나 스텁을 동적으로 생성, 구성, 검증할 수 있게 해주는 프로그램 API
> 

**[격리 프로그램의 장점]**

- 객체의 상호작용 검증, 테스트에 필요한 반복적인 코드 작성을 줄여줌
- 테스트 지속성을 높여줌, 오랜 시간(최소 연 단위로) 개발자가 프로덕션 코드가 변경될 때 마다 테스트 수정 x
    
    프로덕션 코드: 사용자가 실제로 사용하게 될 소스 코드
    

**[격리 프로그램 사용시 주의할 점]**

- 너무 남용하게될 경우에는 테스트를 읽을수도, 신뢰할 수도 없는 상황이 될 수 있으니 주의

### 5.1.1 선택하기: 느슨한 타입 대 정적 타입

---

<aside>
➡️

자바에서 제공되는 격리 프레임워크들

---

- Mockito(가장 많이 쓰임)
- EasyMock
- JMock
- PowerMock 등
</aside>

js 에서는 다양한 프로그래밍 패러다임을 지원하는 덕분에 

격리 프레임워크를 두 가지 유형으로 나눌 수 있음

1. **느슨한 타입의 자바스크립트 격리 프레임워크, 2. 정적 타입의 자바스크립트 격리 프레임워크**
- 자세히
    1. 느슨한 타입의 js 격리 프레임워크
        - 순수 js 친화적인 느슨한 타입의 격리 프레임워크(제스트, 사이넌)
        - 작업을 수행할 때 설정과 보일러 플레이트 코드가 더 적게 필요→ 함수형 스타일 코드에 적합
    2. 정적 타입의 js 격리 프레임워크
        - 더 객체지향적이고, 타입스크립트 친화적인 격리 프레임워크(subsitute.js)
        - 전체 클래스와 인터페이스를 다룰 때 매우 유용
        
    

가장 중요한건 사실 어떤 종류의 의존성을 가짜로 만들어야 하는가가 가장 중요함

- 모듈 의존성(import, require), 함수형 의존성(단일 함수와 고차 함수, 간단한 매개변수)
    
    → 제스트 같은 느슨한 타입의 프레임워크
    

- 객체 전체, 객체 계층 구조, 인터페이스
    
    → subsitute.js 같은 객체 지향적인 프레임워크가 어울림
    

자바에서는 기본이 강한 정적 타입 + 객체/인터페이스 기반

→ 대부분 **Junit** + **Mockito 사용**

 

## 5.2 동적으로 가짜 모듈 만들기

---

<두 가지 의존성을 가진 비밀번호 검증기 도식화>

- 로깅 레벨(INFO 또는 ERROR)을 결정하는 데 도움을 주는 구성 서비스
- 비밀번호를 검증할 때마다 작업 단위의 종료점으로 호출하는 로깅 서비스

![비밀번호 검증기는 로깅 레벨을 결정하는 ‘내부로 들어오는 의존성’과 로그 항목을 생성하는 ‘외부로 나가는 의존성’ 두 개를 갖도 있음](5%EC%9E%A5%20%EA%B2%A9%EB%A6%AC%20%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20253747dafe178073b85cfeae284f50ae/image.png)

비밀번호 검증기는 로깅 레벨을 결정하는 ‘내부로 들어오는 의존성’과 로그 항목을 생성하는 ‘외부로 나가는 의존성’ 두 개를 갖도 있음

화살표 명령(command)과 쿼리(query) 과점에서 생각해 볼 수도 있음 

<aside>
➡️

명령과 쿼리 분리

---

마틴 파울러의 명령과 쿼리 분리 설계 방식 

- **커맨드 (Command):**
    
    객체의 상태를 변경하는 메서드
    
    예를 들어, "데이터를 추가", "객체를 삭제", "값을 설정" 하는 메서드 등이 해당
    
- **쿼리 (Query):**
    
    객체의 상태를 조회하는 메서드
    
    예를 들어, "데이터를 반환", "객체의 속성 값 읽기" 등이 해당
    
</aside>

예제 5-1 모듈 의존성을 하드코딩하기

```java
package ch05.v1;

import java.util.List;
import java.util.function.Predicate;

public class PasswordVerifier {

    private final ConfigurationService config;
    private final ComplicatedLogger logger;

    public PasswordVerifier(final ConfigurationService config, final ComplicatedLogger logger) {
        this.config = config;
        this.logger = logger;
    }

    private void log(String text) {
        String level = config.getLogLevel();
        if("info".equalsIgnoreCase(level)) {
            logger.info(text);
        }
        if("debug".equalsIgnoreCase(level)) {
            logger.debug(text);
        }
    }
    public boolean verifyPassword(String input, List<Predicate<String>> rules) {
        boolean passed = rules.stream().allMatch(rule -> rule.test(input));
        log(passed ? "Passed" : "Failed");
        return passed;
    }
}

```

- `ComplicatedLogger`
    
    ```java
    package ch05.v1;
    
    public interface ComplicatedLogger {
        void info(String text);
        void debug(String text);
    }
    ```
    
- `ConfigurationService`
    
    ```java
    package ch05.v1;
    
    public interface ConfigurationService {
        String getLogLevel();
    }
    ```
    

아래 두 가지 작업 수행해야 됨

- 구성 서비스의 getLogLevel() 함수에서 반환하는 값을 스텁을 사용하여 가짜로 만들어야함
- Logger 모듈의 info 함수가 호출되었는지 모의 함수를 사용하여 검증해야함

![image.png](5%EC%9E%A5%20%EA%B2%A9%EB%A6%AC%20%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20253747dafe178073b85cfeae284f50ae/image%201.png)

내부로 들어오은 의존성(구성 서비스)을 스텁으로 만들고 나가는 의존성(logger)을 목으로 만듬

예제 5-2 Mockito 으로 직접 모듈 API를 가짜로 만들기

```java
package ch05.v1;

import static org.mockito.Mockito.*;
import static org.mockito.BDDMockito.given;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.verify;

import java.util.List;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class PasswordVerifierTest {

    @Mock
    ConfigurationService config;
    @Mock
    ComplicatedLogger logger;

    private PasswordVerifier verifier;

    @BeforeEach
    void setUp() {
        verifier = new PasswordVerifier(config, logger);
    }

    @Test
    void withInfoLevelAndNoRuleCallLoggerWithPASS() {
        given(config.getLogLevel()).willReturn("info");

        // when
        boolean result = verifier.verifyPassword("anything", List.of());

        //then
        assertTrue(result);
        verify(logger).info(matches(".*Passed.*"));
        verify(logger, never()).debug(anyString());
    }

    @Test
    void withDebugLogLevelAndNoRulesCallsLoggerWithPASSED() {
        given(config.getLogLevel()).willReturn("debug");

        // when
        boolean result = verifier.verifyPassword("anything", List.of());

        // then
        assertTrue(result);
        verify(logger).debug(matches(".*Passed.*"));
        verify(logger, never()).info(anyString());
    }
}
```

1. 모듈을 가짜로 만들기
2. @mock 어노테이션을 붙여 가짜 모듈 인스턴스를 불러옴
3. 각 테스트가 끝알 때마다 가짜 객체를 초기화
4. 가짜 모듈의 getLogLevel() 함수의 반환값이 info를 반환하도록 함
5. 가짜 모듈의 모의 함수가 호출되었는지 검증함
6. 이 테스트 내에서 함수의 반환 값이 debug 가 되도록 설정
7. 가짜 모듈의 모의 함수가 호출되었는지 검증함

### 5.2.1 mocktio  API 에 대해 알아둘 점

---

자바 세계에서는 Mockito가 사실상 표준임, 그래서 용어/동작 규칙이 더 명확함

1. Mock vs Stub 구분
- Mockito는 mock() 으로 만든 객체를 mock이라고 부르지만, given(…).willReturn(…)으로 특정 메서드의 응답을 지정하면 그것은 사실상 stub 동작임
- stub = mock 객체의 특정 메서드 동작 정의한다고 이해하면 됨

1. verify는 행위 검증 전용
- verify(mock).someMethod(...)로 호출 여부/횟수/인자를 검증.
- Mockito는 Stub 설정과 Verify가 명확히 분리됨
    
    → when/given은 응답 정의, verify는 호출 검증.
    
- @Mock 으로 생성된 객체는 모든 메서드 호출이 내부적으로 자동 기록하고 있음
    
    → 상태 추적을 위한 외부 변수가 전혀 필요 없음
    

1. 호출 시점
- Mockito는 테스티 메서드 안이나 @BeforeEach 안에서 자유롭게 Mock 생성 가능.
(보통은 @Mock + @ExtendWith(MockitoExtension.class)로 자동 주입)

1. 인자 매처 주의 
- verify(mock).methid(”A”) 처럼 실제 값과 verify(mock).method(anyString())같은 매처는 섞어 쓰면 안됨
    
    (하나라도 매처를 쓰면 전부 매처를 써야 함)
    
    - 더 자세히
        1. Mockito의 기본 검증 방식
        
        ```java
        verify(mock).save("A", 10);
        ```
        
        - "A"와 10은 **실제 값**(literal value)으로 검증하는 것
        - “A”와 10으로 save가 호출되었는지만 체크
        
        1. 매처(Argument Machter) 사용 
        - Mockito는 anyString(), anyInt(), eq(...), matches(...) 같은 인자 매처 제공
        
        ```java
        verify(mock).save(anyString(), anyInt());
        ```
        
        혼용하면 안되는 이유.
        
        - Mockito는 내부적으로 인자 비교 방식을 두 가지 모드 중 하나로 처리함
        - 실제 값 모드: 그냥 .equals() 로 비교
        - 매처 모드: Matchers 로 내부 DSL로 비교
            
            → 혼용시 한가지 모드를 선택하지 못해 예외를 발생
            
        

### 5.2.2 직접 의존성의 추상화 고민

---

문제

1. 외부 라이브러리/SDK를 직접 Mock 하고 싶다.
- 타사 SDK(예: 로깅, 결제, 메시징)를 테스트마다 직접 Mock/Stubbing 하면 테스트가 외부 API 설계에 강결합됨. 버전 변경 시 테스트 대량 수정.

→ 포트와 어댑터 아키텍처(핵사고날 혹은 어니언 아키텍처라고도 함) 사용 권장

- LoggerPort 같은 내부 인터페이스(Port) 정의 → 테스트는 Port만 Mock
- logger 의 참고를 하나의 어댑터 파일에만 연결해서 추상화하는 방식임.(다리 역할)

## 5.3 함수형 스타일의 동적 목과 스텁

---

함수를 가짜로 만드는 방법

목을 수작업으로 만들기에는 번거로움

아래는 수동 접근 방식

- `ComplicatedLogger`
    
    ```java
    package ch05.funcationInterfecMock;
    
    public interface ComplicatedLogger {
        void info(String text);
    }
    ```
    
- `PasswordVerifierFactory`
    
    ```java
    package ch05.funcationInterfecMock;
    
    import java.util.List;
    import java.util.function.Function;
    import java.util.function.Predicate;
    
    public class PasswordVerifierFactory {
    
        public PasswordVerifierFactory() {
        }
    
        public static Function<String, Boolean> makeVerifier(
                List<Predicate<String>> rules,
                ComplicatedLogger logger
        ) {
            return (String input) -> {
                boolean passed = rules.stream().allMatch(r -> r.test(input));
                logger.info(passed ? "Passed" : "Failed");
                return passed;
            };
        }
    }
    ```
    

예제 5-3 모의 함수를 만들고 함수가 호출되었는지 확인하기

```java
package ch05.funcationInterfecMock;

import static org.junit.jupiter.api.Assertions.*;

import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;
import java.util.function.Predicate;
import org.junit.jupiter.api.Test;

class PasswordVerifierFactoryTest {
    @Test
    void givenLoggerAndPassingScenarioWithoutMockito() {
		    //1
        AtomicReference<String> logged = new AtomicReference<>("");
        //2
        ComplicatedLogger mockLog = text -> logged.set(text);

        Function<String, Boolean> verify =
                PasswordVerifierFactory.makeVerifier(List.<Predicate<String>>of(), mockLog);

        Boolean result = verify.apply("any input");

        assertTrue(result);
        //3
        assertTrue(logged.get().matches(".*Passed.*"));
    }
}
```

1. 전달된 값을 저장할 변수 선언
2. 전달된 값을 해당 변수에 저장
3. 변수 값을 검증

예제 5-4 mockito 사용해서 모의 함수 쉽게 만들기

```java
package ch05.funcationInterfecMock;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.contains;
import static org.mockito.Mockito.verify;

import java.util.List;
import java.util.function.Function;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class PasswordVerifierFactoryTestV2 {

    @Mock
    ComplicatedLogger logger;

    @Test
    void giveLoggerAndPassingScenario() {
        Function<String, Boolean> verify =
                PasswordVerifierFactory.makeVerifier(List.of(), logger);

        Boolean result = verify.apply("any input");

        // then
        assertTrue(result);
        verify(logger).info(contains("Passed"));
    }
}
```

어노테이션을 통해 깔끔하게 모의 함수를 만들 수 있음

## 5.4 객체 지향 스타일의 동적 목과 스텁

---

→ js 에서는 함수형 프로그래밍에서는 jest 가 잘동작하지만 클래스나 인터페이스에 사용하려고하면 문제가 생김 

![image.png](5%EC%9E%A5%20%EA%B2%A9%EB%A6%AC%20%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20253747dafe178073b85cfeae284f50ae/image%202.png)

→ 여러 개의 메서드를 가지고 있는 인터페이스

→ 스텁이나 목을 작성하려면 시간이 많이 필요함/각 메서드마다 매개변수를 모두 기억해야함

![아래처럼 스텁을 직접 만드는 경우 보일러 플레이트 코드가 길어질 수 있음 ](5%EC%9E%A5%20%EA%B2%A9%EB%A6%AC%20%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20253747dafe178073b85cfeae284f50ae/image%203.png)

아래처럼 스텁을 직접 만드는 경우 보일러 플레이트 코드가 길어질 수 있음 

하하 그러니 mockito를 써서 인터페이스가 변경되어도 수정이 필요없게 하는 것이 좋다.

추가로 메드가 호출되었는지 검증하기 위해, 호출된 값을 저장할 외부 변수를 선언하고 관리해야함

→ 이로 인해 테스트의 진짜 목적인 행위 검증이 asserTrue(logged.get()..)와 같은 간접적인 방식으로 표현, 의도가 불분명함

<aside>
➡️

격리 프레임워크와 AAA 패턴

---

격리 프레임워크를 사용하는 방식은 우리가 1장에서 살펴본 AAA 패턴과 잘 맞아 떨어짐 

먼저 가짜 객체를 준비(Arrange) 하고

테스트할 동작을 수행(Act)한 후

마지막에 결과를 검증(Assert) 한다.

</aside>

## 5.5 동적 스텁 설정

---

Mocktio는 모듈과 함수 의존성의 반환 값을 조작하는 메서드로 

- `when(...).thenReturn(x)`
- `given(...).willReturn(x)`

제공

예제 5-9 willReturn() 사용하여 모의 함수의 반환 값 조작하기

```java
package ch05.stub;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.BDDMockito.given;

import java.util.function.Supplier;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class JestReturnValuesTest {

    @Mock
    Supplier<String> stubFunc;

    @Test
    void fakeSameReturnValues() {
        given(stubFunc.get()).willReturn("abc");

        // 값이 동일하게 유지됨
        assertEquals("abc", stubFunc.get());
        assertEquals("abc", stubFunc.get());
        assertEquals("abc", stubFunc.get());
    }

    @Test
    void fakeMultipleReturnValues() {
        given(stubFunc.get()).willReturn("a", "b", "c", null);
        assertEquals("a", stubFunc.get());
        assertEquals("b", stubFunc.get());
        assertEquals("c", stubFunc.get());
        assertEquals(null, stubFunc.get()); // JS의 undefined 에 해당
    }
}
```

### 5.5.1 목과 스텁을 사용한 객체 지향 예제

---

**비밀번호 검증기의 또 다른 요소 추가** 

- 소프트웨어가 업데이트되는 유지 보수 가간 동안 비밀번호 검증기가 비활성화된다고 가정
- 유지보수 기간 중에는 비밀번호 검증기의 verify() 를 호출하면 logger.info() 에 Under Main tenance하는 메시지를 전달
- 유지 보수 기간이 아닐 때는 logger.info() 에 passed 또는 failed 결과를 전달

![MaintenanceWindow 인터페이스 사용](5%EC%9E%A5%20%EA%B2%A9%EB%A6%AC%20%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20253747dafe178073b85cfeae284f50ae/image%204.png)

MaintenanceWindow 인터페이스 사용

예제 5-18 MaintenceWindow 의존성을 가진 비밀번호 검증기

```java
package ch05.stub;

import java.util.List;
import java.util.function.Predicate;

public class PasswordVerifier3 {

    private final List<Predicate<String>> rules;
    private final IComplicatedLogger logger;
    private final MaintenanceWindow maintenanceWindow;

    public PasswordVerifier3(
            List<Predicate<String>> rules,
            IComplicatedLogger logger,
            MaintenanceWindow maintenanceWindow
    ) {
        this.rules = rules;
        this.logger = logger;
        this.maintenanceWindow = maintenanceWindow;
    }

    public boolean verify(String input) {
        if (maintenanceWindow.isUnderMaintenance()) {
            logger.info("Under Maintenance", "verify");
            return false;
        }

        boolean passed = rules.stream().allMatch(r -> r.test(input));

        if (passed) {
            logger.info("PASSED", "verify");
            return true;
        }
        logger.info("FAIL", "verify");
        return false;
    }
}
```

- `IComplicatedLogger`
    
    ```java
    package ch05.stub;
    
    public interface IComplicatedLogger {
        void info(String message, String source);
    }
    ```
    
- `MaintenanceWindow`
    
    ```java
    package ch05.stub;
    
    public interface MaintenanceWindow {
        boolean isUnderMaintenance();
    }
    ```
    

### 5.5.2 mockito 스텁과 목

---

![image.png](5%EC%9E%A5%20%EA%B2%A9%EB%A6%AC%20%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20253747dafe178073b85cfeae284f50ae/image%205.png)

→ MaintenanceWindow 인터페이스의 스텁과 IComplicatedLogger 인터체이스의 목 생성

예제 5-11 비밀번호 검증기 테스트하기

```java
package ch05.stub;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;

import java.util.List;
import java.util.function.Predicate;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class PasswordVerifier3Test {

    @Mock
    IComplicatedLogger logger;
    @Mock
    MaintenanceWindow maintenance;

    @Test
    void maintenanceModeBlocksVerificationAndLogsUnderMaintenance() {
        // given
        given(maintenance.isUnderMaintenance()).willReturn(true);
        PasswordVerifier3 sut = new PasswordVerifier3(List.of(), logger, maintenance);

        // when
        boolean result = sut.verify("anything");

        // then
        assertFalse(result);
        verify(logger).info(eq("Under Maintenance"), eq("verify"));
        verifyNoMoreInteractions(logger);
    }

    @Test
    void passesWhenAllRulesPassAndLogsPassed() {
        // given: not under maintenance, 두 규칙 모두 통과
        given(maintenance.isUnderMaintenance()).willReturn(false);
        Predicate<String> pass1 = s -> true;
        Predicate<String> pass2 = s -> s.length() >= 0;
        PasswordVerifier3 sut = new PasswordVerifier3(List.of(pass1, pass2), logger, maintenance);

        // when
        boolean result = sut.verify("abc");

        // then
        assertTrue(result);
        verify(logger).info(eq("PASSED"), eq("verify"));
    }

    @Test
    void failsWhenAnyRuleFailsAndLogsFail() {
        // given: not under maintenance, 하나라도 실패
        given(maintenance.isUnderMaintenance()).willReturn(false);
        Predicate<String> pass = s -> true;
        Predicate<String> fail = s -> false;
        PasswordVerifier3 sut = new PasswordVerifier3(List.of(pass, fail), logger, maintenance);

        // when
        boolean result = sut.verify("abc");

        // then
        assertFalse(result);
        verify(logger).info(eq("FAIL"), eq("verify"));
    }
}
```

## 5.6 격리 프레임워크의 장점과 단점

---

격리 프레임워크의 장점 

- 손쉬운 가짜 모듈 생성
- 값이나 오류를 만들어 내가가 더 쉬워짐
- 가짜 객체 생성이 더 쉬워집

격리 프레임워크의 잠재적인 위험 요소(주의할점)

- 대부분의 경우 Mock 객체는 필요하지 않음
    - Mock은 전체 테스트의 2~5% 정도만 필요.
    - 나머지 대부분은 반환 값 기반 테스트(상태 기반 테스트) 로 충분.
    - Mock/Stubbing 남발은 테스트 난이도를 높이고, 외부 의존성까지 영향을 줌.
    - 단순히 함수 호출 결과(반환값, 상태 변화) 로 검증할 수 있으면 Mock 없이 하는 것이 낫다.
    
- 읽기 어려운 테스트 코드
    - Mock/검증 단계가 너무 많으면 테스트 가독성이 떨어짐.
    - “무엇을 테스트하는지” 이해하기 힘듦 → 테스트 유지보수 어려움.
    - 해결책:
        - 검증 단계 줄이기
        - 큰 테스트를 여러 작은 테스트로 쪼개 가독성 확보

- 잘못된 대상 검증
    - 인터페이스의 메서드나 함수가 호출되었는지 확인할 수 있지만 올바른 대상을 테스트 하고 있는걸 확신할 수 없음.
        - 내부 함수가 다은 내부 함수를 호출했는지 검증 - 종료점이 아닌 경우
        - 스텁이 호출되었는지 검증 - 들어오는 의존성은 검증 x , 과잉 명세 안티 패턴
        - 단순히 누군가가 시켜서? - 요구 사항을 올바르게 이해하는 것이 중요
        
- 테스트당 하나 이상 목을 사용
    - 테스트에서는 하나의 관심사만 검증하는 것이 관행
    - 2개 이상 사용? 동일한 작업 단위의 여러 종료점을 한꺼번에 테스트하는 것과 같음
        
        → 별도의 테스트로 분리
        
    
- 테스트의 과도한 명세화
    - 테스트에 검증 항목이 너무 많으면 아주 작은 프로덕션 코드 변경에도 쉽게 깨질 수 있음
        
        → 양날의 검. 상호작용을 고려해 유지할 것
        
    - 해결
        - 목 대신 스텁사용하기.
        - 가능한 스텁을 목으로 사용하지 않기. → 스텁에서 메서드 호출 여부는 검증하지 않아야 함