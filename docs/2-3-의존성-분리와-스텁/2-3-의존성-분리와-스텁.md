# 3장 의존성 분리와 스텁

---

> 3장
종료점의 마지막 유형인 서드 파티 호출에 대해 다루기
> 

의존성이란?
테스트 대상 코드가 의존하고 있는 외부 요소를 의존성(dependency) 라고 함

- **의존성의 범위**: 시간, 비동기 실행, 파일 시스템, 네트워크 등이 포함
- **의존성 처리 방법:** 코드 리팩터링, 몽키 패칭(monkey-patching) 적용

### 3.1 의존성 유형

---

**[두 가지 유형]**

- 외부로 나가는 의존성
- 내부로 들어오는 의존성

1. 외부로 나가는 의존성
- 작업 단위의 종료점을 나타내는 의존성
- ex) 로거(logger) 함수 호출, 데이터 베이스 저장, 이메일 발송, API나 웹훅에 알림을 보내는 등 작업을 포함
    - 동사로 표현(”호출” , “저장” 등)
    - 작업 단위 → 외부로 흘러가는 일종의 **파이어-앤-포겟(fire-and-forget)**

1. 내부로 들어오는 의존성
    - 종료점을 나타내지 않는 의존성
    - 작업 단위의 최종 동작에 대한 요구사항을 나타내지 않음
    - 단지 테스트에 필요한 특수한 데이터나 동작을 작업 단위에 제공하는 역할
    - ex) 데이터베이스 쿼리 결과, 파일 시스템의 파일 내용, 네트워크 응답 결과 등이 있음
        - 이전 작업의 결과, 작업 단위로 들어오는 수동적인 데이터 조각
        
    
    ![왼쪽: 종료점이 의존성을 호출하는 형태 , 오른쪽: 의존성이 간접적인 입력이나 어떤 동작을 의미하지만 종료점은 아님](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%AB%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%86%B8%2022e747dafe17807db9abf582dddcdd56/image.png)
    
    왼쪽: 종료점이 의존성을 호출하는 형태 , 오른쪽: 의존성이 간접적인 입력이나 어떤 동작을 의미하지만 종료점은 아님
    

<aside>

경우에 따라 어떤 의존성은 위 두 개의 유형을 다 충족하는 경우가 있음 

→ 어떤 테스트에서는 종료점을, 어떤 테스트에서는 데이터 입력으로

ex) 외부 API 가 응답 결과로 성공 및 실패 응답을 받아 서브 파티를 호출

</aside>

의존성은 테스트를 어렵게 만듬.

**[테스트 더블 (Test Double)]**

:  테스트 대상(SUT: System Under Test)이 의존하는 외부 요소를 대체하는 가짜

[Mocks, Fakes, Stubs and Dummies at XUnitPatterns.com](http://xunitpatterns.com/Mocks,%20Fakes,%20Stubs%20and%20Dummies.html)

<xUnit 테스트 패턴>

- 테스트 더블 패턴 종류
    
    
    | 카테고리  | 패턴  | 목적  | 사용법 |
    | --- | --- | --- | --- |
    | - | 테스트 더블  | 스텁과 목을 포함한 전체 개념 (Fake도 포함) | 전체 통칭. 일반적으로 Fake라고 부르기도함 |
    | 스텁(stub) | 더미 객체  | 입력값을 미리 지정해서 테스트할 때 사용.(단순 반환값 등) | 진입점의 매개변수로 보내거나 준비(arrange) 단계에서 사용 |
    |  | 테스트 스텁 | 외부 입력에 따라 다르게 작동하는 로직을 독립적으로 검증할 때 사용 | 의존성으로 주입하고 SUT에 특정 값이나 동작을 반환하도록 구성 |
    | 목(mock) | 테스트 스파이 | 함수가 제대로 호출됐는지, 즉 출력/호출 여부를 검증할 때 사용 | 실제 객체를 오버라이드해서 함수 호출 여부나 횟수를 검증 |
    |  | 모의 객체 | 외부 시스템 호출 같은 간접 출력이 잘 발생했는지 확인 | 가짜 객체를 SUT에 주입한 후 예상대로 호출됐는지 확인 |

**[스텁 vs 목]**

|  | **스텁 (Stub)** | **목 (Mock)** |
| --- | --- | --- |
| 역할 | 내부로 들어오는 의존성(간접 입력)을 끊음 | 외부로 나가는 의존성(간접 출력, 종료점)을 끊음 |
| 목적 | 테스트 대상 코드에 고정된 응답을 제공 (미리 지정한 값 반환) | 외부 시스템(알림, DB 저장 등) 에 대한 호출 여부/횟수/인자를 검증 |
| 특징  | 외부 시스템 대신 동작, 의존성 낮춤 | 종료점 역할, 일반적으로 하나의 테스트에 1개만 사용 |
|  | 호출 여부는 검증하지 않음 → 단순히 값을 돌려줌 |  |
| 예시 | 책 검색 시 DB 접근 없이 미리 지정한 결과 반환 | 주문 확인 이메일 전송 시 실제 이메일은 안 보내지만 이메일 전송 함수 호출 여부 검증 |

<aside>

목업, 목 데이터로 테스트 하겠다….이런말은 스텁과 목을 알고 있는 사람은 헷갈릴수 있는 말이였다.

- **Stub**: “입력 → 정해진 값 반환
- **Mock**: “정해진 방식대로 함수가 **호출되었는지 확인**”

헷갈릴 때는 위 용어들을 포괄하는 테스트 더블이나 페이크라는 용어를 사용하는 것이 더 좋음

</aside>

- 추가 용어 note - 책을 검색하는 예시로 이해해보기
    
    <aside>
    
    - 스텁 : 미리 정의된 가짜 데이터를 제공하여 테스트 대상 코드의 입력을 시뮬레이션
        - 고객이 Harry Potter 책을 검색 → 스텁을 통해 Harry Potter 라는 책 제목을 반환하도록 설정
        - 호출 여부는 검증 x - 값(미리 정의된 가짜 데이터)만 반환
    - 목 : 테스트 대상 코드가 외부 시스템과 상호작용할 때, 호출 여부와 인수를 검증
        - 고객이 Harry Potter 책을 검색 →  장바구니에 추가
        - 데이터베이스에 책이 추가되지 않음,어떤 인수로 호출되었는지 등을 확인하는데 사용
        - 데이터베이스 추가 함수 호출되었는지??
        - 외부 시스템과 상호작용 시뮬레이션
    - 페이크: 실제 구현을 대체하는 가벼운 버전의 구성요소를 제공하여 테스트를 수행함
        - 실제 구현을 대체하는 가벼운 버전의 구성요소
        - 실제 운영 데이터베이스 대신 인메모리 데이터베이스를 사용하여 테스트 수행
    </aside>
    

### 3.2 스텁을 사용하는 이유

---

예제 3-1 시간 함수를 사용하는 verifyPassword() 함수

```java
package ch03;

import java.time.DayOfWeek;
import java.time.LocalDate;

public class PasswordVerifier {
    public void verifyPassword(String input, String rules) {
        DayOfWeek dayOfWeek = **LocalDate**.now().getDayOfWeek();

        if (dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY) {
            throw new RuntimeException("It's the week!");
        }
    }
}
```

`DayOfWeek` : 요일 표현하는 enum 클래스

`LocalDate.now().getDayOfWeek()` : 현재 날찌의 요일을 반환, 반환 타입(DayOfWeek)

[위 코드의 문제점]

- 날짜를 직접 통제하는 것이 아닌 라이브러리가 제공하는 값을 사용하고 있음
    - 테스트의 실행 결과가 현재 날짜와 시간에 따라 달라질 수 있음을 의미
- 주말에는 비밀번호 검증기가 제대로 작동하지 않음 - `error` 발생
- 평일에만 통과하는 테스트.. 주말에는 실패…(버그는 아닌데 결과가 언제 실행하냐에 따라 예측 불가능)

예제 3-2  LocalDate 를 사용하는 verifyPassword()  함수의 초기 테스트 코드

책에 나온 테스트 코드: 주말에 예외발생하는지 test

![image.png](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%AB%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%86%B8%2022e747dafe17807db9abf582dddcdd56/image%201.png)

1. Test 메서드 항상 정의
2. if 조건문 안에 test 함수를 정의 (평일이면 테스트가 아예 생기지도 않게)

**java 에서는 test문 바깥에 if 못씀 → 대안 Assume 사용**

[JUnit 5 User Guide](https://docs.junit.org/current/user-guide/#writing-tests-assumptions)

```java
package ch03;

import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.util.List;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

class PasswordVerifierTest {

    @Nested
    class verifier {
        DayOfWeek dayOfWeek = LocalDate.now().getDayOfWeek();
        PasswordVerifier passwordVerifier;

        @BeforeEach
        void setUp() {
            passwordVerifier = new PasswordVerifier();
        }

        // 이 테스트는 항상 실행되지만, 아무것도 수행하지 않을 수 있음
        @Test
        void onWeekendException() {
            if (dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY) {
                RuntimeException e = assertThrows(RuntimeException.class, () -> {
                    passwordVerifier.verifyPassword("anything", List.of());
                });
                assertTrue(e.getMessage().contains("It's the weekend"));
            }
        }

        // 이 테스트는 주말에만
        @Test
        void testOnlyOnWeekendAssert() {
            assumeTrue(dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY);

            RuntimeException e = assertThrows(RuntimeException.class, () -> {
                passwordVerifier.verifyPassword("anything", List.of());
            });
            assertEquals("It's the weekend!", e.getMessage());
        }
    }
}
```

`assumeTrue` : 조건이 true 면 실행, false 면 스킵

- 또 다른 방식
    
    ```java
    @Test
    void testOnlyOnWeekend() {
        if (!(dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY)) {
            return;
        }
    
        RuntimeException e = assertThrows(RuntimeException.class, () -> {
            passwordVerifier.verifyPassword("anything", List.of());
        });
        assertEquals("It's the weekend!", e.getMessage());
    }
    ```
    
    주말이 아니면 바로 return 해버리는 방법도 있음
    
    package ch03;
    
    import static org.junit.jupiter.api.Assertions.*;
    import static org.junit.jupiter.api.Assumptions.assumeTrue;
    
    import java.time.DayOfWeek;
    import java.time.LocalDate;
    import java.util.List;
    import org.junit.jupiter.api.BeforeEach;
    import org.junit.jupiter.api.Nested;
    import org.junit.jupiter.api.Test;
    
    class PasswordVerifierTest {
    
    ```
    @Nested
    class verifier {
        DayOfWeek dayOfWeek = LocalDate.now().getDayOfWeek();
        PasswordVerifier passwordVerifier;
    
        @BeforeEach
        void setUp() {
            passwordVerifier = new PasswordVerifier();
        }
    
        // 이 테스트는 항상 실행되지만, 아무것도 수행하지 않을 수 있음
        @Test
        void onWeekendException() {
            if (dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY) {
                RuntimeException e = assertThrows(RuntimeException.class, () -> {
                    passwordVerifier.verifyPassword("anything", List.of());
                });
                assertTrue(e.getMessage().contains("It's the weekend"));
            }
        }
    
        // 이 테스트는 주말에만
        @Test
        void testOnlyOnWeekendAssert() {
            assumeTrue(dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY);
    
            RuntimeException e = assertThrows(RuntimeException.class, () -> {
                passwordVerifier.verifyPassword("anything", List.of());
            });
            assertEquals("It's the weekend!", e.getMessage());
        }
    }
    
    ```
    
    }
    

위처럼 테스트 내부에서 날짜를 확인하거나, 외부에서 조건으로 테스트 실행 여부를 제어하는 방식 모두 바람직하지 않음

- 현재 날짜가 주말일 때만 테스트가 의미 있게 실행되고 검증됨
    
    → 주말이 아닌 경우, 테스트가 생략되거나 무의미하게 통과됨
    
- 이는 좋은 테스트의 핵심 기준 중 하나인 일관성(consistency) 에 어긋남
    
    → 테스트는 언제 실행하더라도 같은 결과를 보장해야 함
    
    → 즉, 환경(날짜, 시간 등)에 따라 테스트 결과가 달라지면 안 됨
    

<aside>

테스트의 일관성과 신뢰성을 위해 시간이나 환경에 의존적인 테스트는 피해야함.

시간도 주입 가능한 의존성으로 리팩터링 or 페이크 객체로 대체하는 것이 필요

</aside>

### 3.3 스텁을 사용하는 일반적인 설계 방법

---

[매개변수화(parameterization) 방식]

1. 함수를 사용한 방식
    - 함수를 매개변수로 사용
    - 부분 적용(커링)
    - 팩토리 함수
    - 생성자 함수

1. 모듈을 이용한 방식
    - 모듈 주입

1. 객체 지향을 이용한 방식
    - 클래스 생성자 주입
    - 객체를 매개변수로 사용(일명 덕 타이핑)
    - 공통 인터페이스를 매개변수로 사용

**3.3.1 스텁으로 만든 시간을 매개변수로 주입**

---

**시간을 제어해야 하는 두 가지 이유**: 테스트의 일관성, 시간과 관련된 시나리오들을 쉽게 테스트하기 위함 

1. `PasswordVerifier` 리팩터링

- 함수에 현재 날짜를 뜻하는 `currentDay` 를 매개변수로 추가
- 함수 내에서 java.time API를 사용하지 않아도됨
- 함수를 호출하는 쪽에서 날짜를 전달

```java
public class PasswordVerifierV2 {
    public List<String> verifyPassword(String input, List<String> rules, DayOfWeek currentDay) {
        if (currentDay == DayOfWeek.SATURDAY || currentDay == DayOfWeek.SUNDAY) {
            throw new RuntimeException("It's the weekend!");
        }

        // rules에 따른 검증은 아직 구현되지 않음
        // 향후 규칙 기반 검증 로직 추가 예정
        
        return List.of(); // 발견한 오류 리스트
    }
}
```

1. 테스트 코드 작성 

```java
@DisplayName("verifierV2-dummy object")
class PasswordVerifierV2Test {

    @Test
    void testOnlyOnWeekend() {
        PasswordVerifierV2 passwordVerifier = new PasswordVerifierV2();
        DayOfWeek currentDay = DayOfWeek.SATURDAY;

        RuntimeException e = assertThrows(RuntimeException.class, () -> {
            passwordVerifier.verifyPassword("anything", List.of(), currentDay);
        });

        assertEquals("It's the weekend!", e.getMessage());
    }
}
```

→ 시간 값의 통제권을 함수 호출자(테스트 코드)에 넘겨줌. ***의존성 역전(dependency inversion)의 한 형태.***

![image.png](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%AB%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A5%E1%86%B8%2022e747dafe17807db9abf582dddcdd56/image%202.png)

[리팩터링의 효과]

- 테스트의 일관성 보장
- 라이브러리 독립성 확보
- 테스트 편의성 증가(원하는 날짜 주입 가능)

[설계적인 변화]

- 새로운 의존성이 매개변수로 주입되면서 작업단위의 진입점 바뀜
- verifyPasswordV2는 시간 의존성을 외부로 분리함으로써 순수 함수(Pure Function)에 가까워짐
- 순수 함수?
    - 외부 상태에 의존하지 않음
    - 동일한 입력 → 항상 동일한 출력
    - 테스트가 쉽고, 예측 가능성이 높음
    

3.3.2 의존성, 주입, 제어

---

| 용어 | 설명 |
| --- | --- |
| 의존성(dependency) | 테스트에서 제어할 수 없어 테스트 환경과 코드 유지 보수를 어렵게 만드는 요소를 의미함 |
| 제어(control) | 의존성의 동작을 결정할 수 있는 능력 (테스트에서 시간을 통제할 수 있느냐. 없냐) |
| 제어의 역전(Inversion of Control) | 의존성을 내부에서 생성하지 않고 외부에서 주입받도록 설계 변경 |
| 의존성 주입(Dependency Injection) | 외부에서 사용하는 값을 코드에 매개변수 등으로 주입하는 것 (주입 지점 = 심) |
| 심(Seam) | 외부 값을 주입할 수 있는 지점(매개변수, 함수, 인터페이스, 공용 가상 메서드 등) |

프로덕션 코드에서 심은 단위 테스트의 유지 보수성과 가독성에 중요한 역할을 함

임의의 데이터를 변경하고 주입하기 쉬울수록 테스트를 읽고 유지 보수하는 것이 쉬워짐 

### 3.4 함수를 이용한 주입 방법

---

예제 3-3의 방식 currentDay 매개변수로 주입하여 외부 의존성을 끊고 함수 레벨에서 의존성 문제를 해결. 

→  이 방식은 함수 호출할 때마다 날짜를 계속 전달해야 해서 불편.

시간 의존성을 제거하기 위한 또 다른 방식

- 함수를 이용한 주입 방법

**3.4.1 함수 주입** 

---

예제 3-4 함수를 의존성으로 전달하기

- DayProvider 인터페이스 생성
    
    ```java
    package ch03;
    
    import java.time.DayOfWeek;
    
    @FunctionalInterface
    public interface DayProvider {
        DayOfWeek getDay();
    }
    ```
    
- `PasswordVerifier` 리팩터링
    - 데이터를 의존성으로 직접 받는 대신 데이터를 반환하는 함수(사실 인터페이스)를 매개변수로 받음
    
    ```java
    package ch03;
    
    import java.time.DayOfWeek;
    import java.util.List;
    
    public class PasswordVerifierV3 {
        public List<String> verifyPassword(String input, List<String> rules, DayProvider dayProvider) {
            DayOfWeek dayOfWeek = dayProvider.getDay();
    
            if (dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY) {
                throw new RuntimeException("It's the weekend!");
            }
            // rules에 따른 검증은 아직 구현되지 않음
            // 향후 규칙 기반 검증 로직 추가 예정
    
            return List.of(); // 발견한 오류 리스트
        }
    }
    ```
    

예제 3-5 함수를 의존성으로 주입하는 코드의 테스트 코드

```java
package ch03;

import static org.junit.jupiter.api.Assertions.*;

import java.time.DayOfWeek;
import java.util.List;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

@DisplayName("PasswordVerifier3 - dummy function")
class PasswordVerifierV3Test {
    @Test
    void testOnlyOnWeekendInjectedFunction () {
        //함수 주입 - 항상 SUNDAY 만 반환
        DayProvider sunday = () -> DayOfWeek.SUNDAY;
        PasswordVerifierV3 passwordVerifier = new PasswordVerifierV3();

        RuntimeException e = assertThrows(RuntimeException.class, () -> {
            passwordVerifier.verifyPassword("anything", List.of(), sunday);
        });

        assertEquals(e.getMessage(), "It's the weekend!");
    }
}
```

js 에서는 함수도 값.  함수 자체를 인자로 넘길 수 있음

하지만 Java에서는 함수가 일급객체가 아님.  함수만 단독으로 넘기는 것이 불가능

근데 유사하게 할 수 있음: **함수형 인터페이스( @FunctionalInterface) + 람다** 

- 람다로 함수 구현체를 만들고, 매개 변수로 전달

ex) 함수형 인터페이스 + 람다

```java
DayProvider alwaysSunday = () -> DayOfWeek.SUNDAY;
verifier.verifyPassword("input", List.of(), alwaysSunday);
```

함수 자체를 넘길 수 없으므로, 람다 표현식을 인터페이스의 구현체로 넘기는 식으로 사용

`() -> DayOfWeek.SUNDAY;` : getDay() 메서드를 구현하는 익명 객체

추가로 **Supplier<T> interface 사용 가능**

[☕ 함수형 인터페이스 표준 API 총정리](https://inpa.tistory.com/entry/%E2%98%95-%ED%95%A8%EC%88%98%ED%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-API)

**3.4.2 부분 적용을 이용한 의존성 주입** 

---

자바에서는 고차함수를 직접 만들 수 없음 ,,비슷하게 흉내내기만 가능 

- **고차함수?**
    
    함수를 인자로 받거나, 함수를 반환하는 함수를 말함 = 함수를 다루는 함수
    

예제 3-6 고차 함수 사용하기

```java
package ch03;

import java.time.DayOfWeek;
import java.util.List;
import java.util.function.Function;

// 고차 함수 역할
public class PasswordVerifierFactory {

    public static Function<String, List<String>> makeVerifier(List<String> rules, DayProvider dayProvider) {
        return (input) -> {
            DayOfWeek day = dayProvider.getDay();

            if (day == DayOfWeek.SATURDAY || day == DayOfWeek.SUNDAY) {
                throw new RuntimeException("It's the weekend!");
            }

            // 향후 규칙 기반 검증 로직 추가 예정
            return List.of();
        };
    }
}
```

```java
package ch03;

import static org.junit.jupiter.api.Assertions.*;

import java.time.DayOfWeek;
import java.util.List;
import java.util.function.Function;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

@DisplayName("PasswordVerifier - 고차 함수")
class PasswordVerifierFactoryTest {
        @Test
        void testOnlyOnWeekend() {
            DayProvider sunday = () -> DayOfWeek.SUNDAY;
            Function<String, List<String>> verifier = PasswordVerifierFactory.makeVerifier(List.of(), sunday);

            RuntimeException e = assertThrows(RuntimeException.class, () -> {
                verifier.apply("anything");
            });

            assertEquals("It's the weekend!", e.getMessage());
        }

}
```

### 3.5 모듈을 이용한 주입 방법

---

```java
package ch03;

import java.time.DayOfWeek;
import java.time.LocalDate;

public class PasswordVerifier {
    public void verifyPassword(String input, String rules) {
        DayOfWeek dayOfWeek = LocalDate.now().getDayOfWeek();

        if (dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY) {
            throw new RuntimeException("It's the week!");
        }
    }
}
```

위 코드 처럼 외부와 연결된 직접적인 의존성을 해결할 수 없음 

의존성을 다른 것으로 대체할 수 있도록 코드를 다르게 작성해야함 

의존성을 대체할 수 있는 심을 만들어야 한다.

심을 사용하는 방식 

예제 3-7 필수 의존성 추상화 하기

`TimeProvider` 함수형 인터페이스 정의 

```java
package ch03;

import java.time.DayOfWeek;

@FunctionalInterface
public interface TimeProvider {
    DayOfWeek getDayOfWeek();
}
```

```java
package ch03;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.util.List;

public class PasswordVerifierModuleInjection {

    private TimeProvider timeProvider = () -> LocalDate.now().getDayOfWeek();

    private static final DayOfWeek SATURDAY = DayOfWeek.SATURDAY;
    private static final DayOfWeek SUNDAY = DayOfWeek.SUNDAY;
    
    public PasswordVerifierModuleInjection() {
    }

    public Runnable inject(TimeProvider fake) {
        timeProvider = fake;
        return this::reset;
    }

    public void reset() {
        timeProvider = () -> LocalDate.now().getDayOfWeek(); // 원복
    }

    public TimeProvider getTimeProvider() {
        return timeProvider;
    }

    public List<String> verifyPassword(String input, List<String> rules) {
        DayOfWeek today = timeProvider.getDayOfWeek();

        if (today == SATURDAY || today == SUNDAY) {
            throw new RuntimeException("It's the weekend!");
        }
        return List.of();
    }
}
```

외부 의존성(`LocalDate.now()`)을 직접 사용하지 않고, `TimeProvider`라는 추상화를 통해 주입/복원 가능한 구조

inject() 메서드를 호출하면 reset() 메서드를 반환, 가짜 의존성을 초기 상태로 되돌리는 기능

예제 3-8 inject() 함수를 사용한 가짜 의존성 주입하기

```java
package ch03;

import static org.junit.jupiter.api.Assertions.*;

import java.time.DayOfWeek;
import java.util.List;
import org.junit.jupiter.api.Test;

class PasswordVerifierModuleInjectionTest {

    class InjectHelper {
        public static Runnable injectDate(PasswordVerifierModuleInjection verifier, DayOfWeek fakeDay) {
            return verifier.inject(() -> fakeDay);
        }
    }

    @Test
    void testOnlyOnWeekend() {
        PasswordVerifierModuleInjection verifier = new PasswordVerifierModuleInjection();
        //가짜 날짜를 인수로 넘기면서 injectDate를 호출하여 의존성을 대신
        Runnable reset = InjectHelper.injectDate(verifier, DayOfWeek.SATURDAY);

        RuntimeException e = assertThrows(RuntimeException.class, () ->
                verifier.verifyPassword("abc", List.of())
        );
        assertEquals("It's the weekend!", e.getMessage());

				//의존성 원래 상태로 되돌려놓기
        reset.run();
    }
}
```

- `InjectHelper` : 테스트가 모듈 의존성을 끊을 수 있도록 도와줌
    - inject() 함수 호출 () → fakeDay 전달 → 가짜 날짜 주입
    - inject() 가 Runnable reset 반환

[장점]

- 테스트에서 의존성을 직접 제어할 수 있어 테스트가 정확하고 예측 가능해짐

[단점] 

- 기존 모듈 API 에 강하게 묶이게됨
    - 만약 새로운, 다른 라이브러리로 바꾸게 된다면 테스트가 수백 개가 깨질 수 있음
- 외부 모듈의 구조가 바뀌면 테스트도 전부 수정해야 함
- 모듈 의존성을 주입하면, 해당 API 바뀔 때 전체 코드가 영향을 받음

[해결책]

1. 제어할 수 없는 서드 파티 의존성을 코드에 직접 가져오지 말고, 항상 제어할 수 있는 중간 추상화를 사용해야 함
    - 추천 아키텍처:
        - Hexagonal (Ports and Adapters)
        - Onion Architecture
    - 효과: 외부 변경이 생겨도 내부 테스트나 비즈니스 로직은 영향 안 받음

1. 모듈 직접 주입 대신 다른 주입 방식 사용 
    - 함수의 매개변수 주입
    - 커링(curring)
        - 하나의 함수가 여러 개의 인지를 받는 대신, 인자 하나만 받고, 나머지를 받는 새로운 함수를 반환하는 것
        
        ```jsx
        function curriedAdd(a) {
          return function(b) {
            return a + b;
          };
        }
        
        curriedAdd(1)(2); // 3
        ```
        
    - 인터페이스 + 생성자 주입(java에서 자주씀)
    
    → 의존성을 감추고 유연하게 확장 가능한 코드를 만들어줌
    

<aside>

포트와 어댑터 아키텍처

---

**포트**: 내부 시스템과 외부 세계를 연결하는 인터페이스 역할

- 외부 요청이 어떤 방식으로 들어오는지를 정의함.
- 예: 음악 재생기에서 play(song)이라는 기능

**어댑터:** 포트를 구현하여 구체적인 요청 처리 방식을 제공함

- 예: 로컬 파일에서 음악 재생, 스트리밍 API에서 음악 재생

| 장점 | **포트-어댑터 방식** |
| --- | --- |
| **유연성** | 외부 시스템이 바뀌어도 어댑터만 수정하면 됨. 내부 코드는 영향 X |
| **테스트 용이성** | 어댑터를 가짜로 바꿔 끼워서 테스트 가능 |
| **유지 보수성** | 의존성과 구현 분리가 잘 되어 변경의 영향이 적음 |
- **포트 + 어댑터 방식**
    - MusicPlayerPort 클래스 정의 → 인터페이스처럼 사용
    - LocalMusicPlayerAdapter, StreamingMusicPlayerAdapter가 이를 상속
    - 실제 앱은 이 어댑터들을 주입해서 사용
    - 테스트를 위해 FakeMusicPlayerAdapter 를 생성하여 play 결과를 가짜로 반환
    
    ```jsx
    class MusicPlayerPort {
      play(song) {
        throw new Error("Not implemented");
      }
    }
    
    class LocalMusicPlayerAdapter extends MusicPlayerPort {
      play(song) {
        console.log(`Playing ${song} locally`);
      }
    }
    ```
    
- **모듈 주입 방식**
    - 객체를 정의하고, inject()로 내부 의존성을 바꿈
    - 테스트 시 inject()로 가짜 동작을 주입하고 reset()도 제공
    
    ```jsx
    let dependencies = {
      player: {
        play: (song) => console.log(`Playing ${song}`)
      }
    };
    
    const inject = (fakes) => {
      Object.assign(dependencies, fakes);
    };
    
    const playMusic = (song) => {
      dependencies.player.play(song);
    };
    ```
    
- 비교
    
    
    |  | **포트/어댑터** | **모듈 주입 방식** |
    | --- | --- | --- |
    | **외부 시스템 변경** | 어댑터만 수정 | 전체 코드에 영향 |
    | **테스트 대역 삽입** | 어댑터 교체 | 주입 함수로 변경 |
    | **가독성/구조화** | 명확한 역할 분리 | 구조가 유연하지만 산만해질 수 있음 |
    | **DI 컨테이너 사용** | 사용 가능 | 주로 직접 주입 |
</aside>

### 3.6 생성자 함수를 사용하여 객체 지향적으로 전환

---

예제 3-9 생성자 함수 사용하기

- `PasswordVerifierConstructor` 클래스

```java
package ch03;

import java.time.DayOfWeek;
import java.util.List;

public class PasswordVerifierConstructor {

    private final List<String> rules;
    private final TimeProvider timeProvider;

    public PasswordVerifierConstructor(List<String> rules, TimeProvider timeProvider) {
        this.rules = rules;
        this.timeProvider = timeProvider;
    }

    public List<String> verifyPassword(String input, List<String> rules) {
        DayOfWeek today = timeProvider.getDayOfWeek();

        if (today == DayOfWeek.SATURDAY || today == DayOfWeek.SUNDAY) {
            throw new RuntimeException("It's the weekend!");
        }
        return List.of();
    }
}
```

- **테스트 코드**

```java
package ch03;

import static org.junit.jupiter.api.Assertions.*;

import java.time.DayOfWeek;
import java.util.List;
import org.junit.jupiter.api.Test;

class PasswordVerifierConstructorTest {

    @Test
    void testThrowsExceptionOnWeekend() {
        // Arrange: 항상 일요일을 반환하는 TimeProvider 주입
        TimeProvider sunday = () -> DayOfWeek.SUNDAY;
        PasswordVerifierConstructor verifier = new PasswordVerifierConstructor(List.of(), sunday);

        RuntimeException e = assertThrows(RuntimeException.class, () ->
                verifier.verifyPassword("anything")
        );
        assertEquals("It's the weekend!", e.getMessage());
    }
}
```

객체 지향적으로 만들어야할지 아님 함수형 프로그래밍 으로 만들어야 할지는 현재 프로젝트의 기술 스택, 팀의 상황 등 비기술적인 요소까지 모든 상황을 검토해해야함 

### 3.7 객체 지향적으로 의존성을 주입하는 방법

---

자바. 잘보면 좋음 

**3.7.1 생성자 주입** 

---

- 생성자 주입 방식은 내부 필드에 의존성을 저장하므로 스테이트풀(상태 보유) 구조가 됨
    - 한 번 설정하면 다음부터는 재사용할 수 있어서 반복 작업을 줄일 수 있음

예제 3-10 생성자 주입 방식

예제 3-9 와 동일 

주의. 객체 지향적으로 만들수록 코드가 점점 장황해질 수 있음 

생성자를 이용해서 클래스를 만드는 과정을 팩토리 함수로 분리하면 유지 보수성 관점에서 좋음

예제 3-11 헬퍼 팩토리 함수 추가하기

```java
package ch03;

import static org.junit.jupiter.api.Assertions.*;

import java.time.DayOfWeek;
import java.util.List;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

class PasswordVerifierConstructorTest {
    @Nested
    @DisplayName("helper factory add")
    class helperFactoryAdd {
        //헬퍼 팩토리 함수
        PasswordVerifierConstructor makeVerifier(List<String> rules, TimeProvider timeProvider) {
            return new PasswordVerifierConstructor(rules, timeProvider);
        }

        @Test
        void WeekendThrowsException() {
            TimeProvider sunday = () -> DayOfWeek.SUNDAY;

            PasswordVerifierConstructor verifier = makeVerifier(List.of(), sunday);

            RuntimeException ex = assertThrows(RuntimeException.class, () -> {
                verifier.verifyPassword("anything");
            });

            assertEquals("It's the weekend!", ex.getMessage());
        }

        @Test
        void weekdayNoRulesReturnsEmptyErrorList() {
            TimeProvider monday = () -> DayOfWeek.MONDAY;

            PasswordVerifierConstructor verifier = makeVerifier(List.of(), alwaysMonday);
            List<String> result = verifier.verifyPassword("anything");

            assertEquals(0, result.size());
        }
    }
}
```

`makeVerifier` : 자주 쓰는 생성자를 테스트 내에서 추상화한 헬퍼 팩토리

위의 팩토리 함수는 테스트 내부에 있음 (테스트 내 추상화 계층)

팩토리 함수는 함수형 스타일과 객체 지향 스타일 기반의 코드에서 모두 사용할 수 있음

**3.7.2 함수 대신 객체 주입**

---

예제 3-12 객체 주입하기

매개변수로 함수 대신 객체를 사용할 것.

- `TimeProvider` 을 구현한 `RealTimeProvider`
    
    ```java
    package ch03;
    
    import java.time.DayOfWeek;
    import java.time.LocalDate;
    
    public class RealTimeProvider implements TimeProvider {
        @Override
        public DayOfWeek getDayOfWeek() {
            return LocalDate.now().getDayOfWeek();
        }
    }
    ```
    
- `PasswordVerifierConstructor`
    
    ```java
    package ch03;
    
    import java.time.DayOfWeek;
    import java.util.List;
    
    public class PasswordVerifierConstructor {
    
        private final List<String> rules;
        private final TimeProvider timeProvider;
    
        public PasswordVerifierConstructor(List<String> rules, TimeProvider timeProvider) {
            this.rules = rules;
            this.timeProvider = timeProvider;
        }
    
        public List<String> verifyPassword(String input) {
            DayOfWeek today = timeProvider.getDayOfWeek();
    
            if (today == DayOfWeek.SATURDAY || today == DayOfWeek.SUNDAY) {
                throw new RuntimeException("It's the weekend!");
            }
            return List.of();
        }
    }
    ```
    

```java
class helperFactoryModify {
        //PasswordVerifierConstructor 에 RealTimeProvider 를 의존성으로 주입하는 역할
        PasswordVerifierConstructor makeVerifier(List<String> rules) {
            return new PasswordVerifierConstructor(rules, new RealTimeProvider());
	  }
```

- 테스트 팩토리 함수 수정 → RealTimeProvider 를 의존성으로 주입하는 역할

<aside>

IoC 컨테이너와 의존성 주입

---

- IoC(제어의 역전) DI(의존성 주입)
    - 프로그램 흐름을 직접 제어하지 않고, 외부에서 객체 생겅돠 주입을 맡기는 구조
    - 스프링(Spring), C#의  Autofac, StructureMap등  IoC 컨테이가 이를 자동으로 처리함
- 테스트 시 의존 처리
    - 실서비스에서는 IoC 컨테이너를 통해 TimeProvider를 자동 주입할 수 있지만
    대부분의 경우 커스텀 팩토리 함수를 만들어 의존성을 주입하는 방식으로 전개함
    
    → 왜냐? IoC 없이도 충분히 테스트가 가능하고, 예측 가능하기 떄문
    
</aside>

테스트에서 의존성을 주입할 때 진짜 객체 대신 가짜(Fake) 객체 만들기

`FakeTimeProvider`

```java
package ch03;

import java.time.DayOfWeek;

public class FakeTimeProvider implements TimeProvider {

    private final DayOfWeek fakeDay;

    public FakeTimeProvider(DayOfWeek fakeDay) {
        this.fakeDay = fakeDay;
    }

    @Override
    public DayOfWeek getDayOfWeek() {
        return fakeDay;
    }
}
```

예제 3-13 손수 작성한 스텁 객체 생성하기

```java
@Nested
  @DisplayName("주말 테스트")
  class WeekendBehavior {

      @Test
      @DisplayName("주말이면 예외 발생")
      void shouldThrowExceptionOnWeekend() {
          PasswordVerifierConstructor verifier = new PasswordVerifierConstructor(
                  List.of(),
                  new FakeTimeProvider(DayOfWeek.SUNDAY)  // 또는 SATURDAY
          );

          RuntimeException e = assertThrows(RuntimeException.class, () -> {
              verifier.verifyPassword("anything");
          });

          assertEquals("It's the weekend!", e.getMessage());
      }
  }
}
```

- `js` 는 덕 타이핑이라고 객체가 특정 속성이나 메서드만 갖고 있으면 해당 객체를 특정 역할로 간주하여 사용 가능
- `java` 는 정적 타입 언어. 컴파일 시점에 타입 체크가 이뤄짐. 메서드만 같다고 해서 다른 객체를 대체할 수 없음
    
    인터페이스 기반 설계로 명시적으로 해당 인터페이스응 implements 해야됨 
    

**3.7.3 공통 인터페이스 추출**

---

예제 3-14  공통 인터페이스 추출하기

⇒ 이미 위에서 그렇게 함…어쩔 수 없는 자바란 녀섣ㄱ..

<마지막 말>

원래 테스트가 불가능했던 코드도 “의존성 주입”을 통해 테스트 가능하게 됨.

스텁을 이용해 의존성을 주입해 시간, 네트워크, 랜덤 등 테스트하기 어려운 코드도 안전하게 테스트할 수 있으며, 테스트의 신뢰도와 반복성을 높일 수 있다.