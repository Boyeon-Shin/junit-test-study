# 4장 모의 객체를 사용한 상호 작용 테스트

---

이전까지는 세 가지 종료점 중 두 가지에서만 테스트를 작성했음 

(1. 값을 반환하는 것, 2. 시스템의 상태를 변경하는 것)

> 4장
> 
> 
> 이번 장에서는 **제어 불가능한 외부 시스템(서드 파티 함수, API 등)** 을 호출하는 코드를 테스트함
> 입력 값이 제대로 전달되는지, 외부 함수가 올바르게 호출되는지 확인하는 것이 핵심
> 
> → 이를 위해 목(Mock) 을 사용해 테스트 함
> 

## 4.1 상호 작용 테스트, 목, 스텁

---

상호 작용 테스트: 작업 단위가 제어할 수 없는 영역에 있는 의존성과 어떻게 상호작용하고 메시지를 보내는지(함수를 호출하는지) 확인하는 방법이다.

- 모의 함수(mock function), 모의 객체를 사용하여 외부 의존성을 제대로 호출했는지 검증할 수 있음

- `목 vs 스텁`
    
    목(mock) : 외부로 나가는 의존성과 연결고리를 끊을 때 사용함 
    
    - 가짜로 만든 모듈이나 객체 및 함수
    - 단위 테스트에서 종료점을 나타냄
    - 호출여부를 검증하는 것이 중요함
    
    스텁(stub): 내부로 들어오는 의존성과 연결고리를 끊는데 사용함
    
    - 테스트 코드에 가짜 동작이나 데이터를 제공하는 가짜 모듈, 객체, 함수를 의미함
    - 목과 달리 스텁은 검증할 필요가 없고 하나의 테스트에 여러 개 사용 가능
    - 종료점을 나타내지 않음
    - 최종 결과를 달성하는 과정에서 상호작용일 뿐이므로 종료점으로 취급하지 않음
    

## 4.2 로거 함수에 의존

---

PasswordVerifier 함수가 더욱 복잡해져서 함수 내부에서 로거 함수를 호출하게됨 (로그를 남기는 로직 포함)

로거 함수 - 더 많은 매개변수와 함수를 가지고 있어 인터페이스를 만드는 것도 쉽지 않다고 가정

예제 4-1  복잡한 로거 함수에 직접적으로 의존하기

```java
package ch04;

import java.util.List;
import java.util.function.Predicate;

public class PasswordVerifier {

    private static final ComplicatedLogger logger = new ComplicatedLogger();

    public boolean verifyPassword(String input, List<Predicate<String>> rules) {
        long failCount = rules.stream()
                .filter(rule -> !rule.test(input))
                .count();

        if (failCount == 0) {
            logger.info("PASSED"); // 종료점 1
            return true;
        }

        logger.info("FAIL"); // 종료점 2
        return false;
    }
}
```

- `ComplicatedLogger`
    
    ```java
    package ch04;
    
    public class ComplicatedLogger {
        public void info(String text) {
            System.out.println("INFO: " + text);
        }
    
        public void debug(String text) {
            System.out.println("DEBUG: " + text);
        }
    }
    ```
    

![PasswordVerifier 의 진입점은 verifyPassword 함수, 종료점 2개 (값 반환, `log.info` 함수를 호출)](4%EC%9E%A5%20%EB%AA%A8%EC%9D%98%20%EA%B0%9D%EC%B2%B4%EB%A5%BC%20%EC%82%AC%EC%9A%A9%ED%95%9C%20%EC%83%81%ED%98%B8%20%EC%9E%91%EC%9A%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%2022e747dafe1780658449d40d5441aa56/image.png)

PasswordVerifier 의 진입점은 verifyPassword 함수, 종료점 2개 (값 반환, `log.info` 함수를 호출)

문제점

- 지금 단계에서는 기존에 살펴보았던 방법으로는 로거 함수의 호출 여부를 알 수 없음

해결 

- 코드를 추상화하는 방식으로 해결 가능
- 심(seam)을 사용해볼 것임

[의존성을 추상화하는 일반적인 방법]

- 가짜 객체를 주입하는 방법

| 스타일  | 기법 |
| --- | --- |
| 표준  | 매개변수 추가 |
| 함수형 | 커링 사용, 고차 함수로 변환 |
| 모듈형 | 모듈 의존성 추상화 |
| 객체 지향형 | 타입이 없는 객체 주입, 인터페이스 주입 |

## 4.3 기본 스타일: 매개변수를 주입하는 방식으로 리팩터링

---

리팩터링을 시작하기에 가장 확실하고 간단한 방법 →함수에 매개변수를 추가하기

예제 4-2 가짜 로거 함수를 매개변수로 주입하기

```java
package ch04;

import java.util.List;
import java.util.function.Predicate;

public class PasswordVerifierV2 {

    public boolean verifyPassword(String input, List<Predicate<String>> rules, Logger logger) {
        long failedCount = rules.stream()
                .map(rule -> rule.test(input))
                .filter(result -> result == false)
                .count();

        if (failedCount == 0) {
            logger.info("PASSED");
            return true;
        }

        logger.info("FAIL");
        return false;
    }
}
```

- Logger 인터페이스 정의
    
    ```java
    package ch04;
    
    // 로거 인터페이스 정의
    public interface Logger {
        void info(String message);
    }
    ```
    

예제 4-3 직접 작성한 모의 객체

```java
package ch04;

import static org.junit.jupiter.api.Assertions.*;

import ch04.PasswordVerifierV2.Logger;
import java.util.List;
import org.junit.jupiter.api.Test;

class PasswordVerifierV2Test {
    @Test
    void callsLoggerWithPassedWhenAllRulesPass() {
        // 클로저처럼 값을 기록하기 위한 배열
        final String[] written = {""};

        // 직접 작성한 mock 객체
        Logger mockLogger = new Logger() {
            @Override
            public void info(String text) {
                written[0] = text;
            }
        };

        PasswordVerifierV2 verifier = new PasswordVerifierV2();

        // 규칙이 모두 통과하는 상황
        boolean result = verifier.verifyPassword("anything", List.of(), mockLogger);
        assertTrue(result);

        // 로그 메시지가 PASSED를 포함하는지 확인
        assertTrue(written[0].contains("PASSED"));
    }
}
```

<aside>

모의 객체나 함수를 만들 때 이름이 mock 으로 시작하게 짓는 것을 선호함 

읽는 사람이 해당 목을 검증(Assert, Verification이라고 함) 단계에서 사용하리라고 예상할 수 있게 하려는 것 

</aside>

```java
// 직접 작성한 mock 객체
Logger mockLogger = new Logger() {
    @Override
    public void info(String text) {
        written[0] = text;
    }
};
```

로거 함수의 info 함수와 시그니처가 동일한 프로퍼티를 갖고 있음 

- 매개변수로 전달받는 text 를 written 변수에 저장하여 테스트 코드 내에서 객체 info 함수가 호출되었는지 확인하는 용도로 사용함
    
    → 올바르게 저장되어 있으면 info 함수가 호출됐음을 의미  = 작업 단위에서 종료점이 올바르게 호출되엇음
    

[매개변수 추가 리팩터링 방법]

- 이점
    - 테스트 코드가 로거 구현에 덜 의존적이 됨
        
        → 기존 코드처럼 로거를 직접 import 로 불러오지 않고, 함수 파라미터로 주입함
        
    - 로거를 원하는 방식대로 정의해서 주입할 수 있음
        
        →  함수 시그니처만 맞추면 로거 구현체를 마음대로 교체 가능 (ex: 진짜 로거, 테스트용 mock 로거 등)
        

<aside>

우리가 구현한 형태는 덕 타이핑의 한 형태

어떤 새가 오리처럼 걷고 헤엄치고 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다.

그러므로 오리는 모의 객체가 될 수 있다.

</aside>

## 4.4 목과 스텁을 구분하는 것의 중요성

---

목과 스텁을 정확하게 구분하지 못하면?

복잡한 테스트(한 작업 단위 안에 여러 종료점)를 만들 때가독성과 유지 보수성이 떨어지는 테스트를 만들 수 있음 

- 목은 “요구 사항을 만족했는지” 검증하는 역할 (예: “로거를 호출했다”, “이메일을 보냈다”)

→ 여러 개 목을 쓰면 테스트 목적이 모호해짐.

→ 목이 여러개? 하나의 테스트에서 여러 요구사항을 테스트 한다는 의미가 될 수 있음 

- 스텁은 외부 동작을 시뮬레이션하는 역할 (예: “DB 쿼리가 false를 반환한다”)

→ 값만 반환하고, 검증은 안함 

[구분해서 쓰는 이유]

1. 가독성
    - 테스트 이름만 봐도 뭘 검증하는지 명확해야 한다.
    - 여러 개의 검증이 섞이면 테스트 이름과 실제 동작이 어긋날 수 있음.
    
2. 유지보수성
    - 목과 스텁을 뒤섞으면 불필요한 검증이 테스트 코드에 남음.
    - 예: DB 쿼리를 검증한다고 하면서도 DB 값을 반환받아버림 → 실제 동작과 의미 충돌.
    
3. 신뢰성
    - 하나의 테스트에서 여러 목을 검사하면 첫 번째 목 실패 시 그 다음 코드는 실행되지 않음.
    - 어떤 목에서 실패했는지 명확하게 파악하기 어려움.
    
    → 목은 하나만.
    

<aside>

신뢰성을 해치는 구조 “검증 룰렛”

의사가 환자의 증상 30%만 보고 진단을 내리는 건 위험하다 → 테스트 코드도 마찬가지

여러 개의 검증이 한 테스트에 있으면 어디서 실패했는지 알 수 없음 

</aside>

## 4.5 모듈 스타일의 목

---

모의 객체를 주입하고 그에 대한 응답을 흉내 내는 방법을 살펴볼 것임.

### 4.5.1 실제 예제 코드

---

`verifyPassword` 함수의 두 가지 외부 의존성 

- 로거 함수
- 설정 서비스(configuration-service 파일)
    - 로그 출력에 필요한 로깅 레벨을 반환하는 getLogLevel 함수를 제공함
    - 보통은 이런 로직은 별도의 로거 모듈에 포함시킴
    - 책에서는 외부 의존성과 관계를 명확히 보여주고자 info와 debug 를 호출하는 로직을 테스트 코드에서 작성함
    

예제 4-4 복잡한 모듈 의존성

```java
package ch04;

import java.util.List;
import java.util.function.Predicate;

public class PasswordVerifierV3 {
    private final ConfigurationService config;
    private final Logger logger;

    public PasswordVerifierV3(ConfigurationService config, Logger logger) {
        this.config = config;
        this.logger = logger;
    }

    private void log(String message) {
        String level = config.getLogLevel();
        if ("info".equals(level)) {
            logger.info(message);
        } else if ("debug".equals(level)) {
            logger.debug(message);
        }
    }

    public boolean verifyPassword(String input, List<Predicate<String>> rules) {
        long failed = rules.stream()
                .filter(rule -> !rule.test(input))
                .count();

        if (failed == 0) {
            log("PASSED");
            return true;
        }

        log("FAIL");
        return false;
    }
}

```

- `ConfigurationService`
    
    ```java
    package ch04;
    
    public interface ConfigurationService {
        String getLogLevel();
    }
    ```
    
- `Logger`
    
    ```java
    package ch04;
    
    public interface Logger {
        void info(String text);
        void debug(String text);
    }
    ```
    

원래는 실패가 없을 때만 PASSED 메시지로 로거를 호출해야 하지만, 실패가 있을 때도 로거를 호출하는 버그가 생김

→  위 코드라면 이걸 단위 테스트로 검증하거나 수정 여부를 증명하기 어렵다

**[문제의 원인]**

logger, getLogLevel 등을 코드 내부에서 직접 import (require) 했기 때문

[해결 방법]

- 로거 모듈을 교체려면 모듈 자체를 수정하거나 API 을 활용해야됨 → 권장하지 않음

다른 방법 

### 4.5.2 모듈 주입 방식으로 코드 리팩터링

---

모듈 의존성을 별도의 객체로 분리하여 verifyPassword 함수를 호풀하기 전에 원하는 의존성을 외부에서 주입받도록 할 수 있음 

예제 4-5 모듈 주입 패턴으로 리팩터링하기

```java
package ch04.v4;

import java.util.List;
import java.util.function.Predicate;

public class PasswordVerifier {

    private Logger logger;

    // 기본 생성자 (실제 구현체 주입 가능)
    public PasswordVerifier(Logger logger) {
        this.logger = logger;
    }

    // 의존성 교체 메서드 (inject)
    public void injectLogger(Logger fakeLogger) {
        this.logger = fakeLogger;
    }

    // 의존성 리셋 메서드 (reset)
    public void resetLogger(Logger originalLogger) {
        this.logger = originalLogger;
    }

    // 핵심 로직
    public boolean verifyPassword(String input, List<Predicate<String>> rules) {
        long failedCount = rules.stream()
                .filter(rule -> !rule.test(input))
                .count();

        if (failedCount == 0) {
            logger.info("PASSED");
            return true;
        }

        logger.info("FAIL");
        return false;
    }
}
```

- 모듈 방식으로 작업해 테스트에서 의존성을 비교적 쉽게 바꿀 수 있음
- 의존성을 주입하는 `PasswordVerifier`
- 의존성 교체 `injectLogger`
- 의존성 리셋 `resetLogger`

### 4.5.3  모듈 주입 방식으로 대체한 테스트 예제

---

예제 4-6 모듈 주입 방식의 테스트 코드

```java
package ch04.v4;

import static org.junit.jupiter.api.Assertions.*;

import java.util.List;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;

class PasswordVerifierV4Test {
    private final String[] logged = {""};
    private final Logger mockLogger = new Logger() {
        @Override
        public void info(String message) {
            logged[0] = message;
        }
    };

    private final PasswordVerifierV4 verifier = new PasswordVerifierV4(mockLogger);

    @AfterEach
    void resetLogger() {
        // 원래 logger로 되돌리는 동작 (테스트 격리 유지)
        verifier.resetLogger(mockLogger);
    }

    @Test
    void callsLoggerWithPassWhenNoRulesFail() {
        // 가짜 로거 주입
        verifier.injectLogger(mockLogger);

        // 규칙 모두 통과하는 경우
        verifier.verifyPassword("anything", List.of());

        assertTrue(logged[0].contains("PASSED"));
    }
}
```

- 의존성 주입을 모듈화하고, reset/inject 함수를 공통 유틸처럼 추상화하면 테스트 코드를 더 간결하고 재사용 가능하게 만들 수 있음

## 4.6 함수형 스타일에서 목

---

테스트 대상 코드에 모의 객체를 주입하는데 사용할 수 있는 몇가지 함수형 스타일

### 4.6.1 커링 스타일 사용

---

java에서는 고차함수 + 람다로 커링을 흉내낼 수 있음 

- 커링이란?
    - 여러 개의 인자를 받는 함수를 하나씩 인자를 받아가며 여러 대의 중첩 함수로 나누는 것
    
    ```jsx
    function add(a, b) {
      return a + b;
    }
    
    add(1, 2);  // 결과: 3
    ```
    
    ```jsx
    function add(a) {
    	return function(b) {
    		return a + b;
    	}
    }
    ```
    
    js - lodash 에서의 커링 (_.curry)
    
    - lodash에서는 여러 개의 인자를 받는 함수를 자동으로 커링해줌
    
    ```jsx
    const verifyPassword = _.curry((rules, logger, input) => {
    	//비밀번호 검증...
    });
    ```
    

예제 4-7 verifyPassword 함수에 커링 적용하기

```java
package ch04.v5_curring;

import java.util.List;
import java.util.function.Predicate;

public class PasswordVerifierCurried {

    @FunctionalInterface
    public interface Logger {
        void info(String text);
    }

    // 실제 검증 로직
    @FunctionalInterface
    public interface PasswordChecker {
        boolean verify(String input);
    }

    //커링 스타일: 규칙과 로거 먼저 주입 -> 나중에 비밀번호를 넘겨서 검사
    public static PasswordChecker createVerifier(List<Predicate<String>> rules, Logger logger) {
        return (input) -> {
            long failCount = rules.stream()
                    .map(rule -> rule.test(input))
                    .filter(result -> !result)
                    .count();

            if (failCount == 0) {
                logger.info("PASSWORD");
                return true;
            } else {
                logger.info("FAILED");
                return false;
            }
        };
    }
}
```

createVerifier를 커링 함수로 만들었음 

예제 4-8 커링 함수로 의존성을 주입하는 코드 테스트

```java
class PasswordVerifierCurriedTest {

    @Test
    void returnTrueAndLogsPassedWithWhenAllRulesPass() {
        final String[] logged = {""};

        //Stub logger
        PasswordVerifierCurried.Logger logger = (msg) -> logged[0] += msg;

        //No rules = always pass
        List<Predicate<String>> rules = List.of();

        //커링처럼 rules + logger 를 주입
        PasswordVerifierCurried.PasswordChecker verifier = PasswordVerifierCurried.createVerifier(rules, logger);

        boolean result = verifier.verify("anything");
        assertTrue(result);
        assertEquals("PASSED", logged[0]);
    }
}
```

- 첫 번째 인수: rules 배열, 두 번째 인수: 로거 함수 역할을 대신하는 모의 객체
- 반환된 함수를 변수에 할당해, 함수에 비밀번호에 해당하는 문자열을 인수로 전달하면서 실행

<두 가지를 알 수 있음>

- 이 함수가 실제로 어떻게 사용되고 있는지
- 의존성이 무엇인지

- 코드
    
    ```java
    final String[] logged = {""};
    
    //Stub logger
    PasswordVerifierCurried.Logger logger = (msg) -> logged[0] += msg;
    ```
    
    - Java 에선 람다 안에서 외부 지역변수는 final 또는 effectively final 이어야 함
    - 그래서 배열을 써서 값은 바뀌되 참조는 유지하는 방식으로 우회하는 것
    

### 4.6.2 커링 없이 고차 함수 사용

---

함수형 스타일로 만들 수 있는 또 다른 방식을 보여줌

예제에서는 모든 값을 항상 함수에 전달해야 제대로 동작하기 때문에 커링이 포함되지 않음

예제 4-9 고차 함수에 모의 객체를 의존성으로 주입하기

```java
package ch04.v5_curring;

import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

public class PasswordVerifierNonCurried {

    public static Function<String, Boolean> makeVerifier(
            List<Predicate<String>> rules, Consumer<String> logger
    ) {
        return (input) -> {
            long failCount = rules.stream()
                    .map(rule -> rule.test(input))
                    .filter(result -> !result)
                    .count();

            if (failCount == 0) {
                logger.accept("PASSED");
                return true;
            } else {
                logger.accept("FAILED");
                return false;
            }
        };
    }
}
```

보다 명시적으로 함수를 반환하는 형태인 팩토리(factory) 함수 만들었음 

- 이 함수는 rules(규칙)와 logger(로거)를 받아 클로저 내부에 저장하고, 그 설정을 활용하는 익명 검증 함수를 반환함

예제 4-10 팩토리 함수를 사용하여 테스트 작성하기

```java
package ch04.v5_curring;

import static org.junit.jupiter.api.Assertions.*;

import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import org.junit.jupiter.api.Test;

class PasswordVerifierNonCurriedTest {

    @Test
    void shouldLogPassedWhenAllRulesPassed() {
        //로그 메시지를 저장할 배열
        final String[] logged = {""};

        //빈 규칙 목록 -> 무조건 통과
        List<Predicate<String>> rules = List.of();

        Consumer<String> mockLogger = msg -> logged[0] = msg;

        Function<String, Boolean> passVerifier = PasswordVerifierNonCurried.makeVerifier(rules, mockLogger);

        boolean result = passVerifier.apply("any input");
        assertTrue(result);
        assertEquals("PASSED", logged[0]);
    }
}
```

<aside>

커링과 부분 적용은 개념적으로 유사하지만 몇 가지 차이점이 있음 

---

- 커링: 함수가 하나의 매개변수를 받아 여러 단계를 걸쳐 호출되는 방식임
    - f(a)(b)(c)
- 부분 적용: 여러 매개변수를 받는 함수에서 일부 매개변수를 고정한 새로움 함수를 만드는 방법
    - f(a, b, c) 에서 a, b를 고정한 새로운 함수 g(c) 를 만드는 것
    
    ![image.png](4%EC%9E%A5%20%EB%AA%A8%EC%9D%98%20%EA%B0%9D%EC%B2%B4%EB%A5%BC%20%EC%82%AC%EC%9A%A9%ED%95%9C%20%EC%83%81%ED%98%B8%20%EC%9E%91%EC%9A%A9%20%ED%85%8C%EC%8A%A4%ED%8A%B8%2022e747dafe1780658449d40d5441aa56/image%201.png)
    
    → **두 개념의 공통점**
    
       **모두 고차 함수(higher-order function)를 사용하여 함수를 만든다는 것**
    
    위에서 만든 함수는 엄밀히 말하면 커링이 아니라 부분 적용임
    
</aside>

## 4.7 객체 지향 스타일의 목

---

### 4.7.1 의존성 주입을 위한 코드 리팩터링

---

예제 4-11 클래스 기반 생성자 주입하기 

```java
package ch04.v6;

import java.util.List;
import java.util.function.Consumer;
import java.util.function.Predicate;

public class PasswordVerifierV6 {
    private final List<Predicate<String>> rules;
    private final Consumer<String> logger;

    public PasswordVerifierV6(List<Predicate<String>> rules, Consumer<String> logger) {
        this.rules = rules;
        this.logger = logger;
    }

    public boolean verify(String input){
        long failCount = rules.stream()
                .map(rule -> rule.test(input))
                .filter(result -> !result)
                .count();

        if (failCount == 0){
            logger.accept("PASSED");
            return true;
        }  else {
            logger.accept("FAILED");
            return false;
        }
    }
}
```

예제 4-12 생성자의 매개변수로 모의 로거 함수 주입하기

```java
package ch04.v6;

import static org.junit.jupiter.api.Assertions.*;

import java.util.List;
import java.util.function.Consumer;
import java.util.function.Predicate;
import org.junit.jupiter.api.Test;

class PasswordVerifierV6Test {

    @Test
    void shouldCallLoggerPassedWhenAllRulesPassed() {
        final String[] logged = {""};

        List<Predicate<String>> rules = List.of();

        Consumer<String> mockLogger = msg -> logged[0] = msg;

        PasswordVerifierV6 passwordVerifier = new PasswordVerifierV6(rules, mockLogger);

        boolean result = passwordVerifier.verify("any input");

        assertTrue(result);
        assertEquals("PASSED", logged[0]);
    }
}
```

- 생성자를 통해 규칙과 로거를 전달함 → 객체를 생성할 때 반드시 필요한 의존성을 명확히 알 수 있음
- 의존성 주입이 명확하게 되도록함

자바나 C같은 언어에서는 보통 가짜 로거 함수를 별도의 클래스로 만듬

```java
class FakeLogger {
	logged= "";
	info(text) {
	this.logged = text;
	}
}
```

- 로거를 대체하는 가짜 클래스 이름을 `MockLogger`나 `StubLogger` 라고 짓지 않고 `FakeLogger` 라고 지음, 테스트에서 손쉽게 재사용할 수 있도록 함
    
    →Fake 를 포함함으로써 실제 코드가 아님을 강조
    

### 4.7.2 인터페이스 주입을 이용한 코드 리팩터링

---

인터페이스는 객체지향 프로그램에서 다형성을 제공하는 중요한 역할을 함 

→ 동일한 인터페이스를 구현하는 객체들은 서로 대체 가능하게함.

js, 루비 같은 언어에서는 덕 타이핑을 허용해 인터페이스가 필요하지 않음 

- js는 타입스트립트를 사용해 인터페이스를 활용할 수 있음
- 컴파일러나 트랜스파일러는 타입을 올바르게 사용하는지 확인해줄 수 있음

예제 4-13 프로덕션 코드에 ILogger 인터페이스 적용하기

```java
package ch04.v7;

import java.util.List;
import java.util.function.Consumer;
import java.util.function.Predicate;

public class PasswordVerifier {
    private final List<Predicate<String>> rules;
    private final ILogger logger;

    public PasswordVerifier(List<Predicate<String>> rules, ILogger logger) {
        this.rules = rules;
        this.logger = logger;
    }

    public boolean verify(String input) {
        long failCount = rules.stream()
                .map(rule -> rule.test(input))
                .filter(result -> !result)
                .count();

        if (failCount == 0) {
            logger.info("PASSED");
            return true;
        } else {
            logger.info("FAILED");
            return false;
        }
    }
}
```

- `ILogger`
    
    ```java
    package ch04.v7;
    
    public interface ILogger {
        void info(String text);
    }
    ```
    
- `SimpleLogger`
    
    ```java
    package ch04.v7;
    
    public class SimpleLogger implements ILogger {
        @Override
        public void info(final String text) {
            System.out.println("로그: " + text);
        }
    }
    
    ```
    

예제 4-14 수작업으로 작성한 가짜 ILogger 주입하기

```java
package ch04.v7;

import static org.junit.jupiter.api.Assertions.*;

import ch04.v7.testDouble.FakeLogger;
import java.util.List;
import java.util.function.Predicate;
import org.junit.jupiter.api.Test;

class PasswordVerifierV7Test {

    @Test
    void verifyCallsLoggerWithPassMessage() {
        FakeLogger mockLogger = new FakeLogger();
        List<Predicate<String>> rules = List.of();
        PasswordVerifierV7 verifierV7 = new PasswordVerifierV7(rules, mockLogger);

        verifierV7.verify("anything");
        assertTrue(mockLogger.written.contains("PASSED"));
    }

}
```

- FakeLogger 라는 테스트 용도의 클래스를 직접 만들었음
    
    ```java
    package ch04.v7.testDouble;
    
    import ch04.v7.ILogger;
    
    public class FakeLogger implements ILogger {
        public String written = "";
    
        @Override
        public void info(String text) {
            this.written = text;
        }
    }
    ```
    

함수를 사용하나  모의 객페를 사용하나 코드와 테스트는 동일하게 동작함 

## 4.8 복잡한 인터페이스 다루기

---

인터페이스가 더 복잡해지는 경우 ex) 함수가 여러 개, 각 함수에 여러 매개변수 있을 때 

### 4.8.1 복잡한 인터페이스 예

---

```java
package ch04.v8;

public interface IComplicatedLogger {
    void info(String text);
    void debug(String text, Object obj);
    void warn(String text);
    void error(String text, String location, String stacktrace);
}
```

```java
package ch04.v8;

import java.util.List;
import java.util.function.Predicate;

public class PasswordVerifier2 {
    private final List<Predicate<String>> rules;
    private final IComplicatedLogger logger;

    public PasswordVerifier2(List<Predicate<String>> rules, IComplicatedLogger logger) {
        this.rules = rules;
        this.logger = logger;
    }

    public boolean verify(String input) {
        long failed = rules.stream()
                .map(rule -> rule.test(input))
                .filter(result -> !result)
                .count();

        if (failed == 0) {
            logger.info("PASSED");
            return true;
        } else {
            logger.warn("FAILED");
            return false;
        }
    }
}
```

### 4.8.2 복잡한 인터페이스를 사용하여 테스트 작성

---

```java
package ch04.v8;

public class FakeComplicatedLogger implements IComplicatedLogger {
    public String infoWritten = "";
    public String debugWritten = "";
    public String warnWritten = "";
    public String errorWritten = "";

    @Override
    public void info(String text) {
        infoWritten = text;
    }

    @Override
    public void debug(String text, Object obj) {
        debugWritten = text;
    }

    @Override
    public void warn(String text) {
        warnWritten = text;
    }

    @Override
    public void error(String text, String location, String stacktrace) {
        errorWritten = text;
    }
}
```

```java
package ch04.v8;

import static org.junit.jupiter.api.Assertions.*;

import java.util.List;
import java.util.function.Predicate;
import java.util.function.Supplier;
import org.junit.jupiter.api.Test;

class PasswordVerifierV7Test {

    @Test
    void verifyPassingCallsLoggerWithPASS() {
        FakeComplicatedLogger logger = new FakeComplicatedLogger();

        PasswordVerifierV7 verifier = new PasswordVerifierV7(
                List.of(), // 규칙 없음 -> 무조건 통과
                logger
        );

        verifier.verify("anything");

        assertTrue(logger.infoWritten.contains("PASS"));
    }

    @Test
    void verifyFailingCallsLoggerWithFAIL() {
        FakeComplicatedLogger logger = new FakeComplicatedLogger();

        Predicate<String> alwaysFailRule = input -> false;

        PasswordVerifierV7 verifier = new PasswordVerifierV7(
                List.of(alwaysFailRule),
                logger
        );

        verifier.verify("abc");

        assertTrue(logger.warnWritten.contains("FAILED"));
    }
}

```

→ 모든 인터페이스 함수를 오버라이드(override) 해야 하므로 반복 코드가 생기고 코드 길이가 길어짐

### 4.8.3 복잡한 인터페이스를 직접 사용할 때 단점

---

1. 모든 호출 인자를 수동으로 저장하고 검증해야됨 
    - 인터페이스의 메서드를 호출할 때 전달받은 인자를 테스트에서 변수에 직접 저장해야 함.
    - 매개 변수 확인 번거로움
2. 서드파티 인터페이스에 의존할 경우 시간이 지나며 테스트가 불안정해질 수 있음
3. 긴 인터페이스는 테스트 변경을 유발

해결을 위해 아래 조건을 모두 충족하는 가짜 인터페이스만 사용하길 추천함

- 온전한 제어권이 있는 인터페이스(서드 파티 제공 인터페이스 x)
- 작업 단위나 컴포넌트의 요구 사항에 맞게 설계된 인터페이스여야 함

### 4.8.4 인터페이스 분리 원칙

---

인터페이스 분리 원칙

> “클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다.”
> 
- 인터페이스에 **필요한 것보다 많은 기능**이 들어 있다면, 테스트에서도 불필요한 메서드 구현과 복잡한 매개변수 관리가 필요해짐

## 4.9 부분 모의 객체

---

부분 모의 객체?

- 기본 클래스의 일부 메서드만 오버라이딩하여 테스트에 사용
- 전체 기능은 그대로 두되, 특정 메서드만 가짜로 만드는 것

### 4.9.1 부분 모의 객체를 함수형 방식으로 풀어보기

---

예제 4-17 부분 모의 객체

```java
package ch04.v9;

import static org.junit.jupiter.api.Assertions.*;

import java.util.List;
import org.junit.jupiter.api.Test;

class PasswordVerifierTest {

    @Test
    void verifyWithLoggerCallsLogger() {
        // 부분 모의 객체
        final String[] logged = {""};

        RealLogger testableLog = new RealLogger() {
            @Override
            public void info(String text) {
                logged[0] = text;
            }
        };

        PasswordVerifier verifier = new PasswordVerifier(List.of(), testableLog);
        verifier.verify("any input");

        assertEquals("PASSED", logged[0]);
    }

}
```

### 4.9.2 부분 모의 객체를 객체 지향 방식으로 풀어보기

---

예제 4-18 부분 모의 객체의 객체 지향 스타일 예제

```java
package ch04.v10;

import ch04.v9.RealLogger;

public class TestableLogger extends RealLogger {
    public String logged = "";

    @Override
    public void info(String text) {
        this.logged = text; // 호출 기록 저장
    }
}
```

```java
class PasswordVerifierTest {  
    
    @Test
    void verifyWithLoggerCallsLogger2() {
        // 1. 부분 모의 객체 생성
        TestableLogger mockLog = new TestableLogger();

        // 2. 테스트 대상 객체 생성
        PasswordVerifier verifier = new PasswordVerifier(List.of(), mockLog);

        // 3. 검증
        verifier.verify("any input");

        // 4. info가 호출되었는지 확인
        assertTrue(mockLog.logged.contains("PASSED"));
    }
}
```